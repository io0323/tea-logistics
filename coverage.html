
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>api: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tea-logistics/cmd/api/main.go (0.0%)</option>
				
				<option value="file1">tea-logistics/pkg/auth/utils.go (0.0%)</option>
				
				<option value="file2">tea-logistics/pkg/config/config.go (0.0%)</option>
				
				<option value="file3">tea-logistics/pkg/database/db.go (0.0%)</option>
				
				<option value="file4">tea-logistics/pkg/database/migration.go (0.0%)</option>
				
				<option value="file5">tea-logistics/pkg/handler/delivery_handler.go (56.6%)</option>
				
				<option value="file6">tea-logistics/pkg/handler/notification_handler.go (56.1%)</option>
				
				<option value="file7">tea-logistics/pkg/handlers/auth.go (0.0%)</option>
				
				<option value="file8">tea-logistics/pkg/handlers/delivery.go (0.0%)</option>
				
				<option value="file9">tea-logistics/pkg/handlers/inventory.go (0.0%)</option>
				
				<option value="file10">tea-logistics/pkg/handlers/notification_handler.go (0.0%)</option>
				
				<option value="file11">tea-logistics/pkg/handlers/product.go (0.0%)</option>
				
				<option value="file12">tea-logistics/pkg/handlers/tracking.go (0.0%)</option>
				
				<option value="file13">tea-logistics/pkg/handlers/user.go (0.0%)</option>
				
				<option value="file14">tea-logistics/pkg/middleware/auth.go (0.0%)</option>
				
				<option value="file15">tea-logistics/pkg/middleware/cors.go (0.0%)</option>
				
				<option value="file16">tea-logistics/pkg/models/auth.go (0.0%)</option>
				
				<option value="file17">tea-logistics/pkg/models/role.go (0.0%)</option>
				
				<option value="file18">tea-logistics/pkg/repository/db.go (0.0%)</option>
				
				<option value="file19">tea-logistics/pkg/repository/delivery.go (0.0%)</option>
				
				<option value="file20">tea-logistics/pkg/repository/inventory.go (57.9%)</option>
				
				<option value="file21">tea-logistics/pkg/repository/notification_repository.go (0.0%)</option>
				
				<option value="file22">tea-logistics/pkg/repository/product.go (0.0%)</option>
				
				<option value="file23">tea-logistics/pkg/repository/tracking.go (0.0%)</option>
				
				<option value="file24">tea-logistics/pkg/repository/user.go (0.0%)</option>
				
				<option value="file25">tea-logistics/pkg/routes/auth.go (0.0%)</option>
				
				<option value="file26">tea-logistics/pkg/routes/delivery.go (0.0%)</option>
				
				<option value="file27">tea-logistics/pkg/routes/inventory.go (0.0%)</option>
				
				<option value="file28">tea-logistics/pkg/routes/notification_routes.go (0.0%)</option>
				
				<option value="file29">tea-logistics/pkg/routes/product.go (0.0%)</option>
				
				<option value="file30">tea-logistics/pkg/routes/tracking.go (0.0%)</option>
				
				<option value="file31">tea-logistics/pkg/services/delivery.go (52.6%)</option>
				
				<option value="file32">tea-logistics/pkg/services/inventory.go (37.0%)</option>
				
				<option value="file33">tea-logistics/pkg/services/mocks/notification_service.go (0.0%)</option>
				
				<option value="file34">tea-logistics/pkg/services/mocks/repositories.go (0.0%)</option>
				
				<option value="file35">tea-logistics/pkg/services/notification_service.go (0.0%)</option>
				
				<option value="file36">tea-logistics/pkg/services/product.go (78.6%)</option>
				
				<option value="file37">tea-logistics/pkg/services/tracking.go (0.0%)</option>
				
				<option value="file38">tea-logistics/pkg/services/user.go (0.0%)</option>
				
				<option value="file39">tea-logistics/pkg/tests/test_helpers.go (81.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "database/sql"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "syscall"
        "time"

        "tea-logistics/pkg/config"
        "tea-logistics/pkg/database"
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"
        "tea-logistics/pkg/repository"
        "tea-logistics/pkg/routes"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
        _ "github.com/lib/pq"

        "github.com/joho/godotenv"
)

func init() <span class="cov0" title="0">{
        // 環境変数の読み込み
        if err := godotenv.Load(); err != nil </span><span class="cov0" title="0">{
                log.Printf("警告: .envファイルが読み込めません: %v\n", err)
        }</span>
}

func main() <span class="cov0" title="0">{
        // データベース接続の初期化
        if err := database.InitDB(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("データベース初期化エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer database.CloseDB()

        // マイグレーションの実行
        migrationsDir := filepath.Join("internal", "migrations")
        if err := database.RunMigrations(migrationsDir); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("マイグレーション実行エラー: %v", err)
        }</span>

        // サーバーポートの取得
        <span class="cov0" title="0">port := os.Getenv("SERVER_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">fmt.Printf("サーバーを起動しました。ポート: %s\n", port)

        // 設定の読み込み
        cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("設定の読み込みに失敗しました: %v", err)
        }</span>

        // データベース接続
        <span class="cov0" title="0">db, err := sql.Open("postgres", cfg.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("データベース接続に失敗しました: %v", err)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // データベース接続の確認
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("データベース接続の確認に失敗しました: %v", err)
        }</span>

        // データベースをラップ
        <span class="cov0" title="0">dbWrapper := repository.NewSQLDatabase(db)

        // リポジトリの初期化
        userRepo := repository.NewUserRepository(db)
        productRepo := repository.NewProductRepository(db)
        inventoryRepo := repository.NewInventoryRepository(db)
        trackingRepo := repository.NewTrackingRepository(db)
        notifyRepo := repository.NewSQLNotificationRepository(dbWrapper)
        deliveryRepo := repository.NewSQLDeliveryRepository(dbWrapper)

        // サービスの初期化
        userService := services.NewUserService(userRepo)
        productService := services.NewProductService(productRepo)
        inventoryService := services.NewInventoryService(inventoryRepo)
        trackingService := services.NewTrackingService(trackingRepo)
        notifyService := services.NewNotificationService(notifyRepo, deliveryRepo)
        deliveryService := services.NewDeliveryService(deliveryRepo, inventoryRepo, notifyService)

        // ハンドラの初期化
        userHandler := handlers.NewUserHandler(userService)
        productHandler := handlers.NewProductHandler(productService)
        inventoryHandler := handlers.NewInventoryHandler(inventoryService)
        trackingHandler := handlers.NewTrackingHandler(trackingService)
        notifyHandler := handlers.NewNotificationHandler(notifyService)
        deliveryHandler := handlers.NewDeliveryHandler(deliveryService)

        // Ginルーターの設定
        router := gin.Default()

        // ミドルウェアの設定
        router.Use(gin.Logger())
        router.Use(gin.Recovery())
        router.Use(middleware.CorsMiddleware())

        // ルーティングの設定
        routes.SetupAuthRoutes(router, userHandler)
        routes.SetupProductRoutes(router, productHandler)
        routes.SetupInventoryRoutes(router, inventoryHandler)
        routes.SetupTrackingRoutes(router, trackingHandler)
        routes.SetupNotificationRoutes(router, notifyHandler)
        routes.SetupDeliveryRoutes(router, deliveryHandler)

        // サーバーの設定
        srv := &amp;http.Server{
                Addr:    ":" + port,
                Handler: router,
        }

        // サーバーの起動
        go func() </span><span class="cov0" title="0">{
                if err := srv.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        log.Fatalf("サーバーの起動に失敗しました: %v", err)
                }</span>
        }()

        // シグナルの待機
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        // サーバーのシャットダウン
        log.Println("サーバーをシャットダウンします...")
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        if err := srv.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("サーバーのシャットダウンに失敗しました: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package auth

import (
        "fmt"
        "time"

        "tea-logistics/pkg/models"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

/*
 * 認証ユーティリティパッケージ
 * パスワードのハッシュ化やJWTトークンの生成を行う
 */

const (
        // トークンの有効期限（24時間）
        tokenExpiration = 24 * time.Hour
)

// HashPassword パスワードをハッシュ化する
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        bytes, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("パスワードのハッシュ化エラー: %v", err)
        }</span>
        <span class="cov0" title="0">return string(bytes), nil</span>
}

// CheckPassword パスワードが正しいか確認する
func CheckPassword(password, hash string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(hash), []byte(password))
        return err == nil
}</span>

// GenerateToken JWTトークンを生成する
func GenerateToken(user *models.User, secret string) (string, int64, error) <span class="cov0" title="0">{
        expiresAt := time.Now().Add(tokenExpiration)

        claims := models.TokenClaims{
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(expiresAt),
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
                UserID:   user.ID,
                Username: user.Username,
                Role:     string(user.Role),
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        tokenString, err := token.SignedString([]byte(secret))
        if err != nil </span><span class="cov0" title="0">{
                return "", 0, fmt.Errorf("トークン生成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return tokenString, expiresAt.Unix(), nil</span>
}

// ValidateToken トークンを検証する
func ValidateToken(tokenString, secret string) (*models.TokenClaims, error) <span class="cov0" title="0">{
        token, err := jwt.ParseWithClaims(tokenString, &amp;models.TokenClaims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("予期しない署名方式: %v", token.Header["alg"])
                }</span>
                <span class="cov0" title="0">return []byte(secret), nil</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("トークン検証エラー: %v", err)
        }</span>

        <span class="cov0" title="0">if claims, ok := token.Claims.(*models.TokenClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                return claims, nil
        }</span>

        <span class="cov0" title="0">return nil, fmt.Errorf("無効なトークン")</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package config

import (
        "fmt"
        "os"
)

/*
 * アプリケーション設定
 * 環境変数から設定を読み込む
 */

// Config アプリケーション設定
type Config struct {
        DatabaseURL string
        ServerPort  string
        JWTSecret   string
}

// LoadConfig 環境変数から設定を読み込む
func LoadConfig() (*Config, error) <span class="cov0" title="0">{
        dbURL := os.Getenv("DATABASE_URL")
        if dbURL == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DATABASE_URL が設定されていません")
        }</span>

        <span class="cov0" title="0">port := os.Getenv("SERVER_PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        <span class="cov0" title="0">jwtSecret := os.Getenv("JWT_SECRET")
        if jwtSecret == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("JWT_SECRET が設定されていません")
        }</span>

        <span class="cov0" title="0">return &amp;Config{
                DatabaseURL: dbURL,
                ServerPort:  port,
                JWTSecret:   jwtSecret,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package database

import (
        "database/sql"
        "fmt"
        "os"

        _ "github.com/lib/pq"
)

/*
 * データベース接続を管理するパッケージ
 * PostgreSQLへの接続とコネクションプールの管理を行う
 */

var db *sql.DB

// InitDB データベース接続を初期化する
func InitDB() error <span class="cov0" title="0">{
        connStr := fmt.Sprintf(
                "host=%s port=%s user=%s password=%s dbname=%s sslmode=disable",
                os.Getenv("DB_HOST"),
                os.Getenv("DB_PORT"),
                os.Getenv("DB_USER"),
                os.Getenv("DB_PASSWORD"),
                os.Getenv("DB_NAME"),
        )

        var err error
        db, err = sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("データベース接続エラー: %v", err)
        }</span>

        // コネクションプールの設定
        <span class="cov0" title="0">db.SetMaxOpenConns(25)
        db.SetMaxIdleConns(5)

        // 接続テスト
        if err = db.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("データベース接続テストエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetDB データベース接続を取得する
func GetDB() *sql.DB <span class="cov0" title="0">{
        return db
}</span>

// CloseDB データベース接続を閉じる
func CloseDB() error <span class="cov0" title="0">{
        if db != nil </span><span class="cov0" title="0">{
                return db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package database

import (
        "fmt"
        "io/ioutil"
        "path/filepath"
        "sort"
        "strings"
)

/*
 * データベースマイグレーションを管理するパッケージ
 * マイグレーションファイルの読み込みと実行を行う
 */

// RunMigrations マイグレーションを実行する
func RunMigrations(migrationsDir string) error <span class="cov0" title="0">{
        // マイグレーションファイルの取得
        files, err := ioutil.ReadDir(migrationsDir)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("マイグレーションディレクトリの読み込みエラー: %v", err)
        }</span>

        // SQLファイルのみを抽出してソート
        <span class="cov0" title="0">var migrations []string
        for _, f := range files </span><span class="cov0" title="0">{
                if strings.HasSuffix(f.Name(), ".sql") </span><span class="cov0" title="0">{
                        migrations = append(migrations, f.Name())
                }</span>
        }
        <span class="cov0" title="0">sort.Strings(migrations)

        // マイグレーションの実行
        db := GetDB()
        for _, migration := range migrations </span><span class="cov0" title="0">{
                fmt.Printf("マイグレーションを実行: %s\n", migration)

                // SQLファイルの読み込み
                content, err := ioutil.ReadFile(filepath.Join(migrationsDir, migration))
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("マイグレーションファイルの読み込みエラー: %v", err)
                }</span>

                // トランザクション内でマイグレーションを実行
                <span class="cov0" title="0">tx, err := db.Begin()
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("トランザクション開始エラー: %v", err)
                }</span>

                // SQLの実行
                <span class="cov0" title="0">if _, err := tx.Exec(string(content)); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("マイグレーション実行エラー: %v", err)
                }</span>

                // トランザクションのコミット
                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("トランザクションコミットエラー: %v", err)
                }</span>

                <span class="cov0" title="0">fmt.Printf("マイグレーション完了: %s\n", migration)</span>
        }

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "net/http"
        "strconv"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 配送ハンドラー
 * 配送関連のHTTP APIエンドポイントを実装する
 */

// DeliveryHandler 配送ハンドラー
type DeliveryHandler struct {
        service *services.DeliveryService
}

// NewDeliveryHandler 配送ハンドラーを作成する
func NewDeliveryHandler(service *services.DeliveryService) *DeliveryHandler <span class="cov10" title="6">{
        return &amp;DeliveryHandler{
                service: service,
        }
}</span>

// RegisterRoutes ルートを登録する
func (h *DeliveryHandler) RegisterRoutes(router *gin.Engine) <span class="cov10" title="6">{
        deliveries := router.Group("/api/deliveries")
        </span><span class="cov10" title="6">{
                deliveries.POST("", h.CreateDelivery)
                deliveries.GET("", h.ListDeliveries)
                deliveries.GET("/:id", h.GetDelivery)
                deliveries.PUT("/:id/status", h.UpdateDeliveryStatus)
                deliveries.POST("/:id/complete", h.CompleteDelivery)
                deliveries.POST("/:id/tracking", h.CreateDeliveryTracking)
                deliveries.GET("/:id/tracking", h.ListDeliveryTrackings)
        }</span>
}

// CreateDelivery 配送を作成する
func (h *DeliveryHandler) CreateDelivery(c *gin.Context) <span class="cov1" title="1">{
        var req models.CreateDeliveryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov1" title="1">delivery, err := h.service.CreateDelivery(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, delivery)</span>
}

// ListDeliveries 配送一覧を取得する
func (h *DeliveryHandler) ListDeliveries(c *gin.Context) <span class="cov0" title="0">{
        deliveries, err := h.service.ListDeliveries(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, deliveries)</span>
}

// GetDelivery 配送を取得する
func (h *DeliveryHandler) GetDelivery(c *gin.Context) <span class="cov1" title="1">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov1" title="1">delivery, err := h.service.GetDelivery(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, delivery)</span>
}

// UpdateDeliveryStatus 配送ステータスを更新する
func (h *DeliveryHandler) UpdateDeliveryStatus(c *gin.Context) <span class="cov1" title="1">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov1" title="1">var req struct {
                Status string `json:"status" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.service.UpdateDeliveryStatus(c.Request.Context(), id, req.Status); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusOK)</span>
}

// CompleteDelivery 配送を完了する
func (h *DeliveryHandler) CompleteDelivery(c *gin.Context) <span class="cov1" title="1">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov1" title="1">if err := h.service.CompleteDelivery(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.Status(http.StatusOK)</span>
}

// CreateDeliveryTracking 配送追跡を作成する
func (h *DeliveryHandler) CreateDeliveryTracking(c *gin.Context) <span class="cov1" title="1">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov1" title="1">var req models.CreateTrackingRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov1" title="1">req.DeliveryID = id
        tracking, err := h.service.CreateDeliveryTracking(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusCreated, tracking)</span>
}

// ListDeliveryTrackings 配送追跡履歴を取得する
func (h *DeliveryHandler) ListDeliveryTrackings(c *gin.Context) <span class="cov1" title="1">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov1" title="1">trackings, err := h.service.ListDeliveryTrackings(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov1" title="1">c.JSON(http.StatusOK, trackings)</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "context"
        "encoding/json"
        "net/http"
        "strconv"
        "tea-logistics/pkg/models"

        "github.com/gorilla/mux"
)

/*
 * 通知ハンドラー
 * 通知関連のHTTPエンドポイントを実装する
 */

// NotificationService 通知サービスインターフェース
type NotificationService interface {
        CreateNotification(ctx context.Context, req *models.CreateNotificationRequest) (*models.Notification, error)
        GetNotification(ctx context.Context, id int64) (*models.Notification, error)
        ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error)
        MarkAsRead(ctx context.Context, id int64) error
        DeleteNotification(ctx context.Context, id int64) error
}

// NotificationHandler 通知ハンドラー
type NotificationHandler struct {
        service NotificationService
}

// NewNotificationHandler 通知ハンドラーを作成する
func NewNotificationHandler(service NotificationService) *NotificationHandler <span class="cov10" title="5">{
        return &amp;NotificationHandler{
                service: service,
        }
}</span>

// RegisterRoutes ルートを登録する
func (h *NotificationHandler) RegisterRoutes(router *mux.Router) <span class="cov0" title="0">{
        router.HandleFunc("/notifications", h.CreateNotification).Methods("POST")
        router.HandleFunc("/notifications/{id}", h.GetNotification).Methods("GET")
        router.HandleFunc("/notifications/user/{userID}", h.ListNotifications).Methods("GET")
        router.HandleFunc("/notifications/{id}/read", h.MarkAsRead).Methods("PUT")
        router.HandleFunc("/notifications/{id}", h.DeleteNotification).Methods("DELETE")
}</span>

// CreateNotification 通知を作成する
func (h *NotificationHandler) CreateNotification(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var req models.CreateNotificationRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "リクエストの解析に失敗しました", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">notification, err := h.service.CreateNotification(r.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(http.StatusCreated)
        json.NewEncoder(w).Encode(notification)</span>
}

// GetNotification 通知を取得する
func (h *NotificationHandler) GetNotification(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "無効なID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">notification, err := h.service.GetNotification(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(notification)</span>
}

// ListNotifications ユーザーの通知一覧を取得する
func (h *NotificationHandler) ListNotifications(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        vars := mux.Vars(r)
        userID, err := strconv.ParseInt(vars["userID"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "無効なユーザーID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">notifications, err := h.service.ListNotifications(r.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(notifications)</span>
}

// MarkAsRead 通知を既読にする
func (h *NotificationHandler) MarkAsRead(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "無効なID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if err := h.service.MarkAsRead(r.Context(), id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.WriteHeader(http.StatusNoContent)</span>
}

// DeleteNotification 通知を削除する
func (h *NotificationHandler) DeleteNotification(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        vars := mux.Vars(r)
        id, err := strconv.ParseInt(vars["id"], 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "無効なID", http.StatusBadRequest)
                return
        }</span>

        <span class="cov1" title="1">if err := h.service.DeleteNotification(r.Context(), id); err != nil </span><span class="cov0" title="0">{
                http.Error(w, err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov1" title="1">w.WriteHeader(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "os"
        "time"

        "tea-logistics/pkg/auth"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
)

/*
 * 認証ハンドラ
 * ログインやユーザー登録のリクエストを処理する
 */

// AuthHandler 認証ハンドラ構造体
type AuthHandler struct {
        db *sql.DB
}

// NewAuthHandler 認証ハンドラを作成する
func NewAuthHandler(db *sql.DB) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{db: db}
}</span>

// Login ログイン処理
func (h *AuthHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req models.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        // ユーザーの検索
        <span class="cov0" title="0">var user models.User
        var passwordHash string
        err := h.db.QueryRow(
                "SELECT id, username, email, password_hash, name, role, status FROM users WHERE email = $1",
                req.Email,
        ).Scan(&amp;user.ID, &amp;user.Username, &amp;user.Email, &amp;passwordHash, &amp;user.Name, &amp;user.Role, &amp;user.Status)

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "ユーザー名またはパスワードが正しくありません"})
                return
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "データベースエラー"})
                return
        }</span>

        // パスワードの検証
        <span class="cov0" title="0">if !auth.CheckPassword(req.Password, passwordHash) </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "ユーザー名またはパスワードが正しくありません"})
                return
        }</span>

        // ユーザーのステータスチェック
        <span class="cov0" title="0">if user.Status != models.UserStatusActive </span><span class="cov0" title="0">{
                c.JSON(http.StatusForbidden, gin.H{"error": "アカウントが無効です"})
                return
        }</span>

        // トークンの生成
        <span class="cov0" title="0">token, expiresIn, err := auth.GenerateToken(&amp;user, os.Getenv("JWT_SECRET"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "トークン生成エラー"})
                return
        }</span>

        // アクセストークンの保存
        <span class="cov0" title="0">_, err = h.db.Exec(
                "INSERT INTO access_tokens (user_id, token, expires_at) VALUES ($1, $2, $3)",
                user.ID,
                token,
                time.Unix(expiresIn, 0),
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "トークン保存エラー"})
                return
        }</span>

        // レスポンスの返却
        <span class="cov0" title="0">c.JSON(http.StatusOK, models.LoginResponse{
                Token:     token,
                ExpiresIn: expiresIn,
                User:      user,
        })</span>
}

// Register ユーザー登録処理
func (h *AuthHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req models.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        // パスワードのハッシュ化
        <span class="cov0" title="0">passwordHash, err := auth.HashPassword(req.Password)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "パスワード処理エラー"})
                return
        }</span>

        // ユーザーの作成
        <span class="cov0" title="0">var user models.User
        err = h.db.QueryRow(
                `INSERT INTO users (username, email, password_hash, name, role, status)
                VALUES ($1, $2, $3, $4, $5, $6)
                RETURNING id, created_at, updated_at`,
                req.Username,
                req.Email,
                passwordHash,
                req.Name,
                req.Role,
                models.UserStatusActive,
        ).Scan(&amp;user.ID, &amp;user.CreatedAt, &amp;user.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "ユーザー登録エラー"})
                return
        }</span>

        // ユーザー情報をレスポンスに設定
        <span class="cov0" title="0">user.Username = req.Username
        user.Email = req.Email
        user.Name = req.Name
        user.Role = req.Role
        user.Status = models.UserStatusActive

        c.JSON(http.StatusCreated, gin.H{"message": "ユーザーを登録しました"})</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 配送管理ハンドラ
 * 配送関連のHTTPリクエストを処理する
 */

// DeliveryHandler 配送管理ハンドラ
type DeliveryHandler struct {
        service *services.DeliveryService
}

// NewDeliveryHandler 配送管理ハンドラを作成する
func NewDeliveryHandler(service *services.DeliveryService) *DeliveryHandler <span class="cov0" title="0">{
        return &amp;DeliveryHandler{service: service}
}</span>

// CreateDelivery 配送を作成する
func (h *DeliveryHandler) CreateDelivery(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateDeliveryRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">delivery, err := h.service.CreateDelivery(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, delivery)</span>
}

// ListDeliveries 配送一覧を取得する
func (h *DeliveryHandler) ListDeliveries(c *gin.Context) <span class="cov0" title="0">{
        deliveries, err := h.service.ListDeliveries(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, deliveries)</span>
}

// GetDelivery 配送を取得する
func (h *DeliveryHandler) GetDelivery(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov0" title="0">delivery, err := h.service.GetDelivery(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, delivery)</span>
}

// UpdateDeliveryStatus 配送ステータスを更新する
func (h *DeliveryHandler) UpdateDeliveryStatus(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Status string `json:"status" binding:"required"`
        }
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.UpdateDeliveryStatus(c.Request.Context(), id, req.Status); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

// CompleteDelivery 配送を完了する
func (h *DeliveryHandler) CompleteDelivery(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.CompleteDelivery(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusOK)</span>
}

// CreateDeliveryTracking 配送追跡を作成する
func (h *DeliveryHandler) CreateDeliveryTracking(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov0" title="0">var req models.CreateTrackingRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">req.DeliveryID = id
        tracking, err := h.service.CreateDeliveryTracking(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, tracking)</span>
}

// ListDeliveryTrackings 配送追跡一覧を取得する
func (h *DeliveryHandler) ListDeliveryTrackings(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なID形式です"})
                return
        }</span>

        <span class="cov0" title="0">trackings, err := h.service.ListDeliveryTrackings(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, trackings)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package handlers

import (
        "net/http"
        "strconv"
        "time"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 在庫管理ハンドラ
 * 在庫関連のHTTPリクエストを処理する
 */

// InventoryHandler 在庫管理ハンドラ
type InventoryHandler struct {
        service *services.InventoryService
}

// NewInventoryHandler 在庫管理ハンドラを作成する
func NewInventoryHandler(service *services.InventoryService) *InventoryHandler <span class="cov0" title="0">{
        return &amp;InventoryHandler{service: service}
}</span>

// GetInventory 在庫情報を取得する
func (h *InventoryHandler) GetInventory(c *gin.Context) <span class="cov0" title="0">{
        productID, err := strconv.ParseInt(c.Param("product_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な商品IDです"})
                return
        }</span>

        <span class="cov0" title="0">location := c.Query("location")
        if location == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ロケーションを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">inventory, err := h.service.GetProductInventory(c.Request.Context(), productID, location)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, inventory)</span>
}

// UpdateInventory 在庫を更新する
func (h *InventoryHandler) UpdateInventory(c *gin.Context) <span class="cov0" title="0">{
        type UpdateRequest struct {
                ProductID int64  `json:"product_id" binding:"required"`
                Location  string `json:"location" binding:"required"`
                Quantity  int    `json:"quantity" binding:"required"`
        }

        var req UpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">err := h.service.UpdateInventoryQuantity(
                c.Request.Context(),
                req.ProductID,
                req.Location,
                req.Quantity,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "在庫を更新しました"})</span>
}

// TransferInventory 在庫を移動する
func (h *InventoryHandler) TransferInventory(c *gin.Context) <span class="cov0" title="0">{
        type TransferRequest struct {
                ProductID    int64  `json:"product_id" binding:"required"`
                FromLocation string `json:"from_location" binding:"required"`
                ToLocation   string `json:"to_location" binding:"required"`
                Quantity     int    `json:"quantity" binding:"required"`
        }

        var req TransferRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">err := h.service.TransferInventory(
                c.Request.Context(),
                req.ProductID,
                req.FromLocation,
                req.ToLocation,
                req.Quantity,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "在庫を移動しました"})</span>
}

// CheckAvailability 在庫の利用可能性をチェックする
func (h *InventoryHandler) CheckAvailability(c *gin.Context) <span class="cov0" title="0">{
        productID, err := strconv.ParseInt(c.Param("product_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な商品IDです"})
                return
        }</span>

        <span class="cov0" title="0">location := c.Query("location")
        if location == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "ロケーションを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">quantity, err := strconv.Atoi(c.Query("quantity"))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な数量です"})
                return
        }</span>

        <span class="cov0" title="0">available, err := h.service.CheckAvailability(
                c.Request.Context(),
                productID,
                location,
                quantity,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">message := "在庫が不足しています"
        if available </span><span class="cov0" title="0">{
                message = "在庫は利用可能です"
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "available": available,
                "message":   message,
        })</span>
}

// CreateMovement 在庫移動を作成する
func (h *InventoryHandler) CreateMovement(c *gin.Context) <span class="cov0" title="0">{
        type MovementRequest struct {
                ProductID       int64  `json:"product_id" binding:"required"`
                FromLocation    string `json:"from_location" binding:"required"`
                ToLocation      string `json:"to_location" binding:"required"`
                Quantity        int    `json:"quantity" binding:"required"`
                MovementType    string `json:"movement_type" binding:"required"`
                MovementDate    string `json:"movement_date"`
                ReferenceNumber string `json:"reference_number"`
        }

  var req MovementRequest
  if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
    c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
    return
  }</span>

  // MovementTypeのバリデーション
  <span class="cov0" title="0">validMovementTypes := map[string]bool{
    string(models.MovementTypeInbound):     true,
    string(models.MovementTypeOutbound):    true,
    string(models.MovementTypeTransfer):    true,
    string(models.MovementTypeAdjustment):  true,
  }
  if !validMovementTypes[req.MovementType] </span><span class="cov0" title="0">{
    c.JSON(http.StatusBadRequest, gin.H{"error": "無効な移動タイプです。有効な値: inbound, outbound, transfer, adjustment"})
    return
  }</span>

  <span class="cov0" title="0">var movementTime time.Time
  if req.MovementDate != "" </span><span class="cov0" title="0">{
    // RFC3339想定。異なる形式が必要ならばここで調整
    if t, err := time.Parse(time.RFC3339, req.MovementDate); err == nil </span><span class="cov0" title="0">{
      movementTime = t
    }</span> else<span class="cov0" title="0"> {
      c.JSON(http.StatusBadRequest, gin.H{"error": "movement_dateはRFC3339形式で指定してください"})
      return
    }</span>
  } else<span class="cov0" title="0"> {
    movementTime = time.Now()
  }</span>

  <span class="cov0" title="0">movement, err := h.service.CreateMovement(c.Request.Context(), &amp;models.CreateMovementRequest{
    ProductID:       req.ProductID,
    FromLocation:    req.FromLocation,
    ToLocation:      req.ToLocation,
    Quantity:        req.Quantity,
    MovementType:    models.MovementType(req.MovementType),
    MovementDate:    movementTime,
    ReferenceNumber: req.ReferenceNumber,
  })
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, movement)</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 通知ハンドラ
 * HTTPリクエストを処理し、通知サービスを呼び出す
 */

// NotificationHandler 通知ハンドラ
type NotificationHandler struct {
        service services.NotificationService
}

// NewNotificationHandler 通知ハンドラを作成する
func NewNotificationHandler(service services.NotificationService) *NotificationHandler <span class="cov0" title="0">{
        return &amp;NotificationHandler{
                service: service,
        }
}</span>

// CreateNotification 通知を作成する
func (h *NotificationHandler) CreateNotification(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateNotificationRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエストです"})
                return
        }</span>

        <span class="cov0" title="0">notification, err := h.service.CreateNotification(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, notification)</span>
}

// GetNotification 通知を取得する
func (h *NotificationHandler) GetNotification(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な通知IDです"})
                return
        }</span>

        <span class="cov0" title="0">notification, err := h.service.GetNotification(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, notification)</span>
}

// ListNotifications 通知一覧を取得する
func (h *NotificationHandler) ListNotifications(c *gin.Context) <span class="cov0" title="0">{
        userID, err := strconv.ParseInt(c.Query("user_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なユーザーIDです"})
                return
        }</span>

        <span class="cov0" title="0">notifications, err := h.service.ListNotifications(c.Request.Context(), userID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, notifications)</span>
}

// MarkAsRead 通知を既読にする
func (h *NotificationHandler) MarkAsRead(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な通知IDです"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.MarkAsRead(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}

// DeleteNotification 通知を削除する
func (h *NotificationHandler) DeleteNotification(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な通知IDです"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.DeleteNotification(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.Status(http.StatusNoContent)</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 商品ハンドラ
 * 商品関連のHTTPリクエストを処理する
 */

// ProductHandler 商品ハンドラ
type ProductHandler struct {
        service *services.ProductService
}

// NewProductHandler 商品ハンドラを作成する
func NewProductHandler(service *services.ProductService) *ProductHandler <span class="cov0" title="0">{
        return &amp;ProductHandler{service: service}
}</span>

// CreateProduct 商品作成
func (h *ProductHandler) CreateProduct(c *gin.Context) <span class="cov0" title="0">{
        var req models.CreateProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">product, err := h.service.CreateProduct(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, product)</span>
}

// GetProduct 商品取得
func (h *ProductHandler) GetProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な商品IDです"})
                return
        }</span>

        <span class="cov0" title="0">product, err := h.service.GetProduct(c.Request.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusNotFound, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, product)</span>
}

// ListProducts 商品一覧取得
func (h *ProductHandler) ListProducts(c *gin.Context) <span class="cov0" title="0">{
        products, err := h.service.ListProducts(c.Request.Context())
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, products)</span>
}

// UpdateProduct 商品更新
func (h *ProductHandler) UpdateProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な商品IDです"})
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateProductRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">product, err := h.service.UpdateProduct(c.Request.Context(), id, &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, product)</span>
}

// DeleteProduct 商品削除
func (h *ProductHandler) DeleteProduct(c *gin.Context) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(c.Param("id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な商品IDです"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.DeleteProduct(c.Request.Context(), id); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "商品を削除しました"})</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package handlers

import (
        "net/http"
        "strconv"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * 配送追跡ハンドラ
 * 配送追跡関連のHTTPリクエストを処理する
 */

// TrackingHandler 配送追跡ハンドラ
type TrackingHandler struct {
        service *services.TrackingService
}

// NewTrackingHandler 配送追跡ハンドラを作成する
func NewTrackingHandler(service *services.TrackingService) *TrackingHandler <span class="cov0" title="0">{
        return &amp;TrackingHandler{service: service}
}</span>

// InitializeTracking 配送追跡を初期化する
func (h *TrackingHandler) InitializeTracking(c *gin.Context) <span class="cov0" title="0">{
        deliveryID, err := strconv.ParseInt(c.Param("delivery_id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効な配送IDです"})
                return
        }</span>

        <span class="cov0" title="0">fromLocation := c.Query("from_location")
        if fromLocation == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "出発地点を指定してください"})
                return
        }</span>

        <span class="cov0" title="0">tracking, err := h.service.InitializeTracking(c.Request.Context(), deliveryID, fromLocation)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, tracking)</span>
}

// UpdateTrackingStatus 配送追跡ステータスを更新する
func (h *TrackingHandler) UpdateTrackingStatus(c *gin.Context) <span class="cov0" title="0">{
        type UpdateRequest struct {
                Status      models.TrackingStatus `json:"status" binding:"required"`
                Location    string                `json:"location" binding:"required"`
                Description string                `json:"description" binding:"required"`
        }

        trackingID := c.Param("tracking_id")
        if trackingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "追跡IDを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">var req UpdateRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">err := h.service.UpdateTrackingStatus(
                c.Request.Context(),
                trackingID,
                req.Status,
                req.Location,
                req.Description,
        )
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "追跡ステータスを更新しました"})</span>
}

// AddTrackingEvent 配送追跡イベントを追加する
func (h *TrackingHandler) AddTrackingEvent(c *gin.Context) <span class="cov0" title="0">{
        trackingID := c.Param("tracking_id")
        if trackingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "追跡IDを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">var event models.TrackingEvent
        if err := c.ShouldBindJSON(&amp;event); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">event.TrackingID = trackingID
        if err := h.service.AddTrackingEvent(c.Request.Context(), &amp;event); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, event)</span>
}

// GetTrackingInfo 配送追跡情報を取得する
func (h *TrackingHandler) GetTrackingInfo(c *gin.Context) <span class="cov0" title="0">{
        trackingID := c.Param("tracking_id")
        if trackingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "追跡IDを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">tracking, err := h.service.GetTrackingInfo(c.Request.Context(), trackingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, tracking)</span>
}

// SetTrackingCondition 追跡条件を設定する
func (h *TrackingHandler) SetTrackingCondition(c *gin.Context) <span class="cov0" title="0">{
        trackingID := c.Param("tracking_id")
        if trackingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "追跡IDを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">var condition models.TrackingCondition
        if err := c.ShouldBindJSON(&amp;condition); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">condition.TrackingID = trackingID
        if err := h.service.SetTrackingCondition(c.Request.Context(), &amp;condition); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, condition)</span>
}

// GetTrackingCondition 追跡条件を取得する
func (h *TrackingHandler) GetTrackingCondition(c *gin.Context) <span class="cov0" title="0">{
        trackingID := c.Param("tracking_id")
        if trackingID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "追跡IDを指定してください"})
                return
        }</span>

        <span class="cov0" title="0">condition, err := h.service.GetTrackingCondition(c.Request.Context(), trackingID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, condition)</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package handlers

import (
        "net/http"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/services"

        "github.com/gin-gonic/gin"
)

/*
 * ユーザーハンドラ
 * ユーザー関連のHTTPリクエストを処理する
 */

// UserHandler ユーザーハンドラ
type UserHandler struct {
        service *services.UserService
}

// NewUserHandler ユーザーハンドラを作成する
func NewUserHandler(service *services.UserService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{service: service}
}</span>

// Login ログイン処理
func (h *UserHandler) Login(c *gin.Context) <span class="cov0" title="0">{
        var req models.LoginRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.service.Login(c.Request.Context(), &amp;req)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"token": token})</span>
}

// Register 登録処理
func (h *UserHandler) Register(c *gin.Context) <span class="cov0" title="0">{
        var req models.RegisterRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.Register(c.Request.Context(), &amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusCreated, gin.H{"message": "ユーザーを登録しました"})</span>
}

// GetProfile プロフィール取得
func (h *UserHandler) GetProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "認証が必要です"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.service.GetProfile(c.Request.Context(), userID.(int64))
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, user)</span>
}

// UpdateProfile プロフィール更新
func (h *UserHandler) UpdateProfile(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "認証が必要です"})
                return
        }</span>

        <span class="cov0" title="0">var req models.UpdateProfileRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.UpdateProfile(c.Request.Context(), userID.(int64), &amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "プロフィールを更新しました"})</span>
}

// ChangePassword パスワード変更
func (h *UserHandler) ChangePassword(c *gin.Context) <span class="cov0" title="0">{
        userID, exists := c.Get("user_id")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "認証が必要です"})
                return
        }</span>

        <span class="cov0" title="0">var req models.ChangePasswordRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "無効なリクエスト形式です"})
                return
        }</span>

        <span class="cov0" title="0">if err := h.service.ChangePassword(c.Request.Context(), userID.(int64), &amp;req); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "パスワードを変更しました"})</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package middleware

import (
        "fmt"
        "net/http"
        "strings"

        "tea-logistics/pkg/config"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
        "github.com/golang-jwt/jwt"
)

/*
 * 認証ミドルウェア
 * JWTトークンによる認証を行う
 */

// AuthMiddleware 認証ミドルウェア
func AuthMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                authHeader := c.GetHeader("Authorization")
                if authHeader == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "認証が必要です"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">tokenString := strings.Replace(authHeader, "Bearer ", "", 1)
                cfg, err := config.LoadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "設定の読み込みに失敗しました"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">token, err := jwt.Parse(tokenString, func(token *jwt.Token) (interface{}, error) </span><span class="cov0" title="0">{
                        if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("無効な署名方式です: %v", token.Header["alg"])
                        }</span>
                        <span class="cov0" title="0">return []byte(cfg.JWTSecret), nil</span>
                })

                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "無効なトークンです"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">if claims, ok := token.Claims.(jwt.MapClaims); ok &amp;&amp; token.Valid </span><span class="cov0" title="0">{
                        userID := int64(claims["user_id"].(float64))
                        role := models.Role(claims["role"].(string))
                        c.Set("user_id", userID)
                        c.Set("role", role)
                        c.Next()
                }</span> else<span class="cov0" title="0"> {
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "無効なトークンです"})
                        c.Abort()
                        return
                }</span>
        }
}

// RoleAuth ロール認証ミドルウェア
func RoleAuth(allowedRoles ...models.Role) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                role, exists := c.Get("role")
                if !exists </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "認証が必要です"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">userRole := role.(models.Role)
                for _, allowedRole := range allowedRoles </span><span class="cov0" title="0">{
                        if userRole == allowedRole </span><span class="cov0" title="0">{
                                c.Next()
                                return
                        }</span>
                }

                <span class="cov0" title="0">c.JSON(http.StatusForbidden, gin.H{"error": "権限がありません"})
                c.Abort()</span>
        }
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package middleware

import (
        "github.com/gin-gonic/gin"
)

/*
 * CORSミドルウェア
 * クロスオリジンリソース共有の設定を行う
 */

// CorsMiddleware CORSミドルウェアを設定する
func CorsMiddleware() gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                c.Writer.Header().Set("Access-Control-Allow-Origin", "*")
                c.Writer.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                c.Writer.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")
                c.Writer.Header().Set("Access-Control-Max-Age", "86400")

                if c.Request.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        c.AbortWithStatus(204)
                        return
                }</span>

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package models

import (
        "time"

        "github.com/golang-jwt/jwt/v5"
        "golang.org/x/crypto/bcrypt"
)

/*
 * 認証関連モデル
 * ユーザー認証とアクセス制御を管理する
 */

// User ユーザー情報
type User struct {
        ID        int64     `json:"id"`
        Username  string    `json:"username"`
        Email     string    `json:"email"`
        Password  string    `json:"-"` // パスワードはJSONに含めない
        Name      string    `json:"name"`
        Role      Role      `json:"role"`
        Status    string    `json:"status"`
        CreatedAt time.Time `json:"created_at"`
        UpdatedAt time.Time `json:"updated_at"`
}

// UserStatus ユーザーステータス定数
const (
        UserStatusActive   = "active"
        UserStatusInactive = "inactive"
        UserStatusBlocked  = "blocked"
)

// LoginRequest ログインリクエスト
type LoginRequest struct {
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=8"`
}

// LoginResponse ログインレスポンス
type LoginResponse struct {
        Token     string `json:"token"`
        ExpiresIn int64  `json:"expires_in"`
        User      User   `json:"user"`
}

// RegisterRequest 登録リクエスト
type RegisterRequest struct {
        Username string `json:"username" binding:"required"`
        Email    string `json:"email" binding:"required,email"`
        Password string `json:"password" binding:"required,min=8"`
        Name     string `json:"name" binding:"required"`
        Role     Role   `json:"role" binding:"required"`
}

// UpdateProfileRequest プロフィール更新リクエスト
type UpdateProfileRequest struct {
        Name string `json:"name" binding:"required"`
}

// ChangePasswordRequest パスワード変更リクエスト
type ChangePasswordRequest struct {
        OldPassword string `json:"old_password" binding:"required"`
        NewPassword string `json:"new_password" binding:"required,min=8"`
}

// TokenClaims JWTトークンのクレーム
type TokenClaims struct {
        jwt.RegisteredClaims
        UserID   int64  `json:"user_id"`
        Username string `json:"username"`
        Role     string `json:"role"`
}

// HashPassword パスワードをハッシュ化する
func (u *User) HashPassword() error <span class="cov0" title="0">{
        hashedPassword, err := bcrypt.GenerateFromPassword([]byte(u.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">u.Password = string(hashedPassword)
        return nil</span>
}

// CheckPassword パスワードを検証する
func (u *User) CheckPassword(password string) bool <span class="cov0" title="0">{
        err := bcrypt.CompareHashAndPassword([]byte(u.Password), []byte(password))
        return err == nil
}</span>
</pre>
		
		<pre class="file" id="file17" style="display: none">package models

/*
 * ロールモデル
 * ユーザーの権限を定義する
 */

// Role ユーザーロール
type Role string

const (
        RoleAdmin    Role = "admin"
        RoleManager  Role = "manager"
        RoleOperator Role = "operator"
        RoleViewer   Role = "viewer"
)

// IsValidRole ロールが有効かどうかを確認する
func IsValidRole(role Role) bool <span class="cov0" title="0">{
        switch role </span>{
        case RoleAdmin, RoleManager, RoleOperator, RoleViewer:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// HasPermission 指定されたロールの権限を持っているかどうかを確認する
func HasPermission(role Role, required Role) bool <span class="cov0" title="0">{
        switch role </span>{
        case RoleAdmin:<span class="cov0" title="0">
                return true</span>
        case RoleManager:<span class="cov0" title="0">
                return required != RoleAdmin</span>
        case RoleOperator:<span class="cov0" title="0">
                return required == RoleOperator || required == RoleViewer</span>
        case RoleViewer:<span class="cov0" title="0">
                return required == RoleViewer</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "context"
        "database/sql"
)

/*
 * DBインターフェース
 * SQLデータベースの操作を抽象化する
 */

// DB データベースインターフェース
type DB interface {
        ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error)
        QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error)
        QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row
        GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error
}

// SQLDatabase SQLデータベースの実装
type SQLDatabase struct {
        *sql.DB
}

// NewSQLDatabase SQLデータベースを作成する
func NewSQLDatabase(db *sql.DB) DB <span class="cov0" title="0">{
        return &amp;SQLDatabase{db}
}</span>

// GetContext 単一の行を取得する
func (db *SQLDatabase) GetContext(ctx context.Context, dest interface{}, query string, args ...interface{}) error <span class="cov0" title="0">{
        row := db.QueryRowContext(ctx, query, args...)
        return row.Scan(dest)
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * 配送管理リポジトリ
 * データベースとの配送関連の操作を管理する
 */

// DeliveryRepository 配送リポジトリインターフェース
type DeliveryRepository interface {
        CreateDelivery(ctx context.Context, delivery *models.Delivery) error
        GetDelivery(ctx context.Context, id int64) (*models.Delivery, error)
        ListDeliveries(ctx context.Context) ([]*models.Delivery, error)
        UpdateDelivery(ctx context.Context, delivery *models.Delivery) error
        CreateDeliveryItem(ctx context.Context, item *models.DeliveryItem) error
        ListDeliveryItems(ctx context.Context, deliveryID int64) ([]*models.DeliveryItem, error)
        CreateDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error
        ListDeliveryTrackings(ctx context.Context, deliveryID int64) ([]*models.DeliveryTracking, error)
}

// SQLDeliveryRepository SQL配送管理リポジトリ
type SQLDeliveryRepository struct {
        db DB
}

// NewSQLDeliveryRepository SQL配送管理リポジトリを作成する
func NewSQLDeliveryRepository(db DB) DeliveryRepository <span class="cov0" title="0">{
        return &amp;SQLDeliveryRepository{db: db}
}</span>

// CreateDelivery 配送を作成する
func (r *SQLDeliveryRepository) CreateDelivery(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        query := `
                INSERT INTO deliveries (
                        order_id, status, from_warehouse_id,
                        to_address, estimated_time, actual_time,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $7)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                delivery.OrderID,
                delivery.Status,
                delivery.FromWarehouseID,
                delivery.ToAddress,
                delivery.EstimatedTime,
                delivery.ActualTime,
                now,
        ).Scan(&amp;delivery.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">delivery.CreatedAt = now
        delivery.UpdatedAt = now
        return nil</span>
}

// GetDelivery 配送を取得する
func (r *SQLDeliveryRepository) GetDelivery(ctx context.Context, id int64) (*models.Delivery, error) <span class="cov0" title="0">{
        delivery := &amp;models.Delivery{}
        query := `
                SELECT id, order_id, status, from_warehouse_id,
                        to_address, estimated_time, actual_time,
                        created_at, updated_at
                FROM deliveries
                WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;delivery.ID,
                &amp;delivery.OrderID,
                &amp;delivery.Status,
                &amp;delivery.FromWarehouseID,
                &amp;delivery.ToAddress,
                &amp;delivery.EstimatedTime,
                &amp;delivery.ActualTime,
                &amp;delivery.CreatedAt,
                &amp;delivery.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return delivery, nil</span>
}

// ListDeliveries 配送一覧を取得する
func (r *SQLDeliveryRepository) ListDeliveries(ctx context.Context) ([]*models.Delivery, error) <span class="cov0" title="0">{
        query := `
                SELECT id, order_id, status, from_warehouse_id,
                        to_address, estimated_time, actual_time,
                        created_at, updated_at
                FROM deliveries
                ORDER BY id`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var deliveries []*models.Delivery
        for rows.Next() </span><span class="cov0" title="0">{
                delivery := &amp;models.Delivery{}
                err := rows.Scan(
                        &amp;delivery.ID,
                        &amp;delivery.OrderID,
                        &amp;delivery.Status,
                        &amp;delivery.FromWarehouseID,
                        &amp;delivery.ToAddress,
                        &amp;delivery.EstimatedTime,
                        &amp;delivery.ActualTime,
                        &amp;delivery.CreatedAt,
                        &amp;delivery.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配送データ読み取りエラー: %v", err)
                }</span>
                <span class="cov0" title="0">deliveries = append(deliveries, delivery)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return deliveries, nil</span>
}

// UpdateDelivery 配送を更新する
func (r *SQLDeliveryRepository) UpdateDelivery(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        query := `
                UPDATE deliveries
                SET order_id = $1, status = $2, from_warehouse_id = $3,
                        to_address = $4, estimated_time = $5, actual_time = $6,
                        updated_at = $7
                WHERE id = $8`

        result, err := r.db.ExecContext(ctx, query,
                delivery.OrderID,
                delivery.Status,
                delivery.FromWarehouseID,
                delivery.ToAddress,
                delivery.EstimatedTime,
                delivery.ActualTime,
                time.Now(),
                delivery.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// CreateDeliveryItem 配送商品を作成する
func (r *SQLDeliveryRepository) CreateDeliveryItem(ctx context.Context, item *models.DeliveryItem) error <span class="cov0" title="0">{
        query := `
                INSERT INTO delivery_items (
                        delivery_id, product_id, quantity
                ) VALUES ($1, $2, $3)
                RETURNING id`

        err := r.db.QueryRowContext(ctx, query,
                item.DeliveryID,
                item.ProductID,
                item.Quantity,
        ).Scan(&amp;item.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送商品作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ListDeliveryItems 配送商品一覧を取得する
func (r *SQLDeliveryRepository) ListDeliveryItems(ctx context.Context, deliveryID int64) ([]*models.DeliveryItem, error) <span class="cov0" title="0">{
        query := `
                SELECT id, delivery_id, product_id, quantity
                FROM delivery_items
                WHERE delivery_id = $1
                ORDER BY id`

        rows, err := r.db.QueryContext(ctx, query, deliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送商品一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var items []*models.DeliveryItem
        for rows.Next() </span><span class="cov0" title="0">{
                item := &amp;models.DeliveryItem{}
                err := rows.Scan(
                        &amp;item.ID,
                        &amp;item.DeliveryID,
                        &amp;item.ProductID,
                        &amp;item.Quantity,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配送商品データ読み取りエラー: %v", err)
                }</span>
                <span class="cov0" title="0">items = append(items, item)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送商品一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return items, nil</span>
}

// CreateDeliveryTracking 配送追跡を作成する
func (r *SQLDeliveryRepository) CreateDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error <span class="cov0" title="0">{
        query := `
                INSERT INTO delivery_trackings (
                        delivery_id, location, status,
                        notes, created_at
                ) VALUES ($1, $2, $3, $4, $5)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                tracking.DeliveryID,
                tracking.Location,
                tracking.Status,
                tracking.Notes,
                now,
        ).Scan(&amp;tracking.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">tracking.CreatedAt = now
        return nil</span>
}

// ListDeliveryTrackings 配送追跡一覧を取得する
func (r *SQLDeliveryRepository) ListDeliveryTrackings(ctx context.Context, deliveryID int64) ([]*models.DeliveryTracking, error) <span class="cov0" title="0">{
        query := `
                SELECT id, delivery_id, location, status, notes, created_at
                FROM delivery_trackings
                WHERE delivery_id = $1
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, deliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var trackings []*models.DeliveryTracking
        for rows.Next() </span><span class="cov0" title="0">{
                tracking := &amp;models.DeliveryTracking{}
                err := rows.Scan(
                        &amp;tracking.ID,
                        &amp;tracking.DeliveryID,
                        &amp;tracking.Location,
                        &amp;tracking.Status,
                        &amp;tracking.Notes,
                        &amp;tracking.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配送追跡データ読み取りエラー: %v", err)
                }</span>
                <span class="cov0" title="0">trackings = append(trackings, tracking)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return trackings, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * 在庫管理リポジトリ
 * データベースとの在庫関連の操作を管理する
 */

// SQLInventoryRepository SQL在庫管理リポジトリ
type SQLInventoryRepository struct {
        db *sql.DB
}

// NewInventoryRepository 在庫管理リポジトリを作成する
func NewInventoryRepository(db *sql.DB) InventoryRepository <span class="cov10" title="7">{
        return &amp;SQLInventoryRepository{db: db}
}</span>

// CreateInventory 在庫を作成する
func (r *SQLInventoryRepository) CreateInventory(ctx context.Context, inventory *models.Inventory) error <span class="cov4" title="2">{
        query := `
                INSERT INTO inventory (
                        product_id, quantity, location, status,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $5)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                inventory.ProductID,
                inventory.Quantity,
                inventory.Location,
                inventory.Status,
                now,
        ).Scan(&amp;inventory.ID)

        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("在庫作成エラー: %v", err)
        }</span>

        <span class="cov1" title="1">inventory.CreatedAt = now
        inventory.UpdatedAt = now
        return nil</span>
}

// GetInventory 在庫を取得する
func (r *SQLInventoryRepository) GetInventory(ctx context.Context, id int64) (*models.Inventory, error) <span class="cov4" title="2">{
        inventory := &amp;models.Inventory{}
        query := `
                SELECT id, product_id, quantity, location, status,
                        created_at, updated_at
                FROM inventory
                WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;inventory.ID,
                &amp;inventory.ProductID,
                &amp;inventory.Quantity,
                &amp;inventory.Location,
                &amp;inventory.Status,
                &amp;inventory.CreatedAt,
                &amp;inventory.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("在庫が見つかりません")
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventory, nil</span>
}

// ListInventories 在庫一覧を取得する
func (r *SQLInventoryRepository) ListInventories(ctx context.Context) ([]*models.Inventory, error) <span class="cov0" title="0">{
        query := `
                SELECT id, product_id, quantity, location, status,
                        created_at, updated_at
                FROM inventory
                ORDER BY id`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var inventories []*models.Inventory
        for rows.Next() </span><span class="cov0" title="0">{
                inventory := &amp;models.Inventory{}
                err := rows.Scan(
                        &amp;inventory.ID,
                        &amp;inventory.ProductID,
                        &amp;inventory.Quantity,
                        &amp;inventory.Location,
                        &amp;inventory.Status,
                        &amp;inventory.CreatedAt,
                        &amp;inventory.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("在庫データ読み取りエラー: %v", err)
                }</span>
                <span class="cov0" title="0">inventories = append(inventories, inventory)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return inventories, nil</span>
}

// UpdateInventory 在庫を更新する
func (r *SQLInventoryRepository) UpdateInventory(ctx context.Context, inventory *models.Inventory) error <span class="cov0" title="0">{
        query := `
                UPDATE inventory
                SET product_id = $1, quantity = $2, location = $3,
                        status = $4, updated_at = $5
                WHERE id = $6`

        result, err := r.db.ExecContext(ctx, query,
                inventory.ProductID,
                inventory.Quantity,
                inventory.Location,
                inventory.Status,
                time.Now(),
                inventory.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫が見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteInventory 在庫を削除する
func (r *SQLInventoryRepository) DeleteInventory(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM inventory WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫削除エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫が見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInventoryByProduct 商品IDから在庫を取得する
func (r *SQLInventoryRepository) GetInventoryByProduct(ctx context.Context, productID int64) (*models.Inventory, error) <span class="cov4" title="2">{
        inventory := &amp;models.Inventory{}
        query := `
                SELECT id, product_id, quantity, location, status,
                        created_at, updated_at
                FROM inventory
                WHERE product_id = $1`

        err := r.db.QueryRowContext(ctx, query, productID).Scan(
                &amp;inventory.ID,
                &amp;inventory.ProductID,
                &amp;inventory.Quantity,
                &amp;inventory.Location,
                &amp;inventory.Status,
                &amp;inventory.CreatedAt,
                &amp;inventory.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("在庫が見つかりません")
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventory, nil</span>
}

// UpdateQuantity 在庫数を更新する
func (r *SQLInventoryRepository) UpdateQuantity(ctx context.Context, id int64, quantity int) error <span class="cov4" title="2">{
        query := `
                UPDATE inventory
                SET quantity = $1, updated_at = $2
                WHERE id = $3`

        result, err := r.db.ExecContext(ctx, query,
                quantity,
                time.Now(),
                id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫数更新エラー: %v", err)
        }</span>

        <span class="cov4" title="2">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov4" title="2">if rows == 0 </span><span class="cov1" title="1">{
                return fmt.Errorf("在庫が見つかりません")
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetInventoryByLocation 場所から在庫を取得する
func (r *SQLInventoryRepository) GetInventoryByLocation(ctx context.Context, location string) ([]*models.Inventory, error) <span class="cov4" title="2">{
        query := `
                SELECT id, product_id, quantity, location, status,
                        created_at, updated_at
                FROM inventory
                WHERE location = $1
                ORDER BY id`

        rows, err := r.db.QueryContext(ctx, query, location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫一覧取得エラー: %v", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        var inventories []*models.Inventory
        for rows.Next() </span><span class="cov4" title="2">{
                inventory := &amp;models.Inventory{}
                err := rows.Scan(
                        &amp;inventory.ID,
                        &amp;inventory.ProductID,
                        &amp;inventory.Quantity,
                        &amp;inventory.Location,
                        &amp;inventory.Status,
                        &amp;inventory.CreatedAt,
                        &amp;inventory.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("在庫データ読み取りエラー: %v", err)
                }</span>
                <span class="cov4" title="2">inventories = append(inventories, inventory)</span>
        }

        <span class="cov4" title="2">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov4" title="2">return inventories, nil</span>
}

// CreateMovement 在庫移動を作成する
func (r *SQLInventoryRepository) CreateMovement(ctx context.Context, movement *models.InventoryMovement) error <span class="cov4" title="2">{
        query := `
                INSERT INTO inventory_movements (
                        product_id, from_location, to_location,
                        quantity, movement_type, movement_date,
                        reference_number, created_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                movement.ProductID,
                movement.FromLocation,
                movement.ToLocation,
                movement.Quantity,
                movement.MovementType,
                movement.MovementDate,
                movement.ReferenceNumber,
                now,
        ).Scan(&amp;movement.ID)

        if err != nil </span><span class="cov1" title="1">{
                return fmt.Errorf("在庫移動作成エラー: %v", err)
        }</span>

        <span class="cov1" title="1">movement.CreatedAt = now
        return nil</span>
}

// ListMovements 在庫移動履歴を取得する
func (r *SQLInventoryRepository) ListMovements(ctx context.Context, productID int64) ([]*models.InventoryMovement, error) <span class="cov4" title="2">{
        query := `
                SELECT id, product_id, from_location, to_location,
                        quantity, movement_type, movement_date,
                        reference_number, created_at
                FROM inventory_movements
                WHERE product_id = $1
                ORDER BY movement_date DESC`

        rows, err := r.db.QueryContext(ctx, query, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫移動履歴取得エラー: %v", err)
        }</span>
        <span class="cov4" title="2">defer rows.Close()

        var movements []*models.InventoryMovement
        for rows.Next() </span><span class="cov4" title="2">{
                movement := &amp;models.InventoryMovement{}
                err := rows.Scan(
                        &amp;movement.ID,
                        &amp;movement.ProductID,
                        &amp;movement.FromLocation,
                        &amp;movement.ToLocation,
                        &amp;movement.Quantity,
                        &amp;movement.MovementType,
                        &amp;movement.MovementDate,
                        &amp;movement.ReferenceNumber,
                        &amp;movement.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("在庫移動データ読み取りエラー: %v", err)
                }</span>
                <span class="cov4" title="2">movements = append(movements, movement)</span>
        }

        <span class="cov4" title="2">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫移動履歴読み取りエラー: %v", err)
        }</span>

        <span class="cov4" title="2">return movements, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "encoding/json"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * 通知リポジトリ
 * 通知関連のデータベース操作を実装する
 */

// NotificationRepository 通知リポジトリインターフェース
type NotificationRepository interface {
        // CreateNotification 通知を作成する
        CreateNotification(ctx context.Context, notification *models.Notification) error

        // GetNotification 通知を取得する
        GetNotification(ctx context.Context, id int64) (*models.Notification, error)

        // ListNotifications ユーザーの通知一覧を取得する
        ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error)

        // UpdateNotificationStatus 通知ステータスを更新する
        UpdateNotificationStatus(ctx context.Context, id int64, status models.NotificationStatus) error

        // DeleteNotification 通知を削除する
        DeleteNotification(ctx context.Context, id int64) error
}

// SQLNotificationRepository SQL通知リポジトリ
type SQLNotificationRepository struct {
        db DB
}

// NewSQLNotificationRepository SQL通知リポジトリを作成する
func NewSQLNotificationRepository(db DB) NotificationRepository <span class="cov0" title="0">{
        return &amp;SQLNotificationRepository{db: db}
}</span>

// CreateNotification 通知を作成する
func (r *SQLNotificationRepository) CreateNotification(ctx context.Context, notification *models.Notification) error <span class="cov0" title="0">{
        query := `
                INSERT INTO notifications (
                        type, status, title, message,
                        data, user_id, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5::jsonb, $6, $7, $7)
                RETURNING id`

        now := time.Now()

        // データをJSONに変換
        var jsonData []byte
        var err error
        if notification.Data != nil </span><span class="cov0" title="0">{
                jsonData, err = json.Marshal(notification.Data)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("データのJSON変換エラー: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                jsonData = []byte("{}")
        }</span>

        <span class="cov0" title="0">err = r.db.QueryRowContext(ctx, query,
                notification.Type,
                notification.Status,
                notification.Title,
                notification.Message,
                jsonData,
                notification.UserID,
                now,
        ).Scan(&amp;notification.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("通知作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">notification.CreatedAt = now
        notification.UpdatedAt = now
        return nil</span>
}

// GetNotification 通知を取得する
func (r *SQLNotificationRepository) GetNotification(ctx context.Context, id int64) (*models.Notification, error) <span class="cov0" title="0">{
        notification := &amp;models.Notification{}
        query := `
                SELECT id, type, status, title, message,
                        data, user_id, created_at, updated_at
                FROM notifications
                WHERE id = $1`

        var jsonData []byte
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;notification.ID,
                &amp;notification.Type,
                &amp;notification.Status,
                &amp;notification.Title,
                &amp;notification.Message,
                &amp;jsonData,
                &amp;notification.UserID,
                &amp;notification.CreatedAt,
                &amp;notification.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知取得エラー: %v", err)
        }</span>

        // JSONデータをmapに変換
        <span class="cov0" title="0">if len(jsonData) &gt; 0 </span><span class="cov0" title="0">{
                if err := json.Unmarshal(jsonData, &amp;notification.Data); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("データのJSON変換エラー: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                notification.Data = make(map[string]interface{})
        }</span>

        <span class="cov0" title="0">return notification, nil</span>
}

// ListNotifications 通知一覧を取得する
func (r *SQLNotificationRepository) ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error) <span class="cov0" title="0">{
        query := `
                SELECT id, type, status, title, message,
                        data, user_id, created_at, updated_at
                FROM notifications
                WHERE user_id = $1
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var notifications []*models.Notification
        for rows.Next() </span><span class="cov0" title="0">{
                notification := &amp;models.Notification{}
                var jsonData []byte
                err := rows.Scan(
                        &amp;notification.ID,
                        &amp;notification.Type,
                        &amp;notification.Status,
                        &amp;notification.Title,
                        &amp;notification.Message,
                        &amp;jsonData,
                        &amp;notification.UserID,
                        &amp;notification.CreatedAt,
                        &amp;notification.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("通知データ読み取りエラー: %v", err)
                }</span>

                // JSONデータをmapに変換
                <span class="cov0" title="0">if len(jsonData) &gt; 0 </span><span class="cov0" title="0">{
                        if err := json.Unmarshal(jsonData, &amp;notification.Data); err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("データのJSON変換エラー: %v", err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        notification.Data = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">notifications = append(notifications, notification)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return notifications, nil</span>
}

// UpdateNotificationStatus 通知ステータスを更新する
func (r *SQLNotificationRepository) UpdateNotificationStatus(ctx context.Context, id int64, status models.NotificationStatus) error <span class="cov0" title="0">{
        query := `
                UPDATE notifications
                SET status = $1, updated_at = $2
                WHERE id = $3`

        result, err := r.db.ExecContext(ctx, query,
                status,
                time.Now(),
                id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("通知ステータス更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteNotification 通知を削除する
func (r *SQLNotificationRepository) DeleteNotification(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM notifications WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("通知削除エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * 商品リポジトリ
 * データベースとの商品関連の操作を管理する
 */

// SQLProductRepository SQL商品リポジトリ
type SQLProductRepository struct {
        db *sql.DB
}

// NewProductRepository 商品リポジトリを作成する
func NewProductRepository(db *sql.DB) ProductRepository <span class="cov0" title="0">{
        return &amp;SQLProductRepository{db: db}
}</span>

// CreateProduct 商品を作成する
func (r *SQLProductRepository) CreateProduct(ctx context.Context, product *models.Product) error <span class="cov0" title="0">{
        query := `
                INSERT INTO products (
                        name, description, price, status,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $5)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                product.Name,
                product.Description,
                product.Price,
                product.Status,
                now,
        ).Scan(&amp;product.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("商品作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">product.CreatedAt = now
        product.UpdatedAt = now
        return nil</span>
}

// GetProduct 商品を取得する
func (r *SQLProductRepository) GetProduct(ctx context.Context, id int64) (*models.Product, error) <span class="cov0" title="0">{
        product := &amp;models.Product{}
        query := `
                SELECT id, name, description, price, status,
                        created_at, updated_at
                FROM products
                WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;product.ID,
                &amp;product.Name,
                &amp;product.Description,
                &amp;product.Price,
                &amp;product.Status,
                &amp;product.CreatedAt,
                &amp;product.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品が見つかりません")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return product, nil</span>
}

// ListProducts 商品一覧を取得する
func (r *SQLProductRepository) ListProducts(ctx context.Context) ([]*models.Product, error) <span class="cov0" title="0">{
        query := `
                SELECT id, name, description, price, status,
                        created_at, updated_at
                FROM products
                ORDER BY id`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品一覧取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var products []*models.Product
        for rows.Next() </span><span class="cov0" title="0">{
                product := &amp;models.Product{}
                err := rows.Scan(
                        &amp;product.ID,
                        &amp;product.Name,
                        &amp;product.Description,
                        &amp;product.Price,
                        &amp;product.Status,
                        &amp;product.CreatedAt,
                        &amp;product.UpdatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("商品データ読み取りエラー: %v", err)
                }</span>
                <span class="cov0" title="0">products = append(products, product)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品一覧読み取りエラー: %v", err)
        }</span>

        <span class="cov0" title="0">return products, nil</span>
}

// UpdateProduct 商品を更新する
func (r *SQLProductRepository) UpdateProduct(ctx context.Context, product *models.Product) error <span class="cov0" title="0">{
        query := `
                UPDATE products
                SET name = $1, description = $2, price = $3,
                        status = $4, updated_at = $5
                WHERE id = $6`

        result, err := r.db.ExecContext(ctx, query,
                product.Name,
                product.Description,
                product.Price,
                product.Status,
                time.Now(),
                product.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("商品更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("商品が見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteProduct 商品を削除する
func (r *SQLProductRepository) DeleteProduct(ctx context.Context, id int64) error <span class="cov0" title="0">{
        query := `DELETE FROM products WHERE id = $1`

        result, err := r.db.ExecContext(ctx, query, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("商品削除エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("商品が見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * 配送追跡リポジトリ
 * データベースとの配送追跡関連の操作を管理する
 */

// TrackingRepository 配送追跡リポジトリ
type TrackingRepository struct {
        db *sql.DB
}

// NewTrackingRepository 配送追跡リポジトリを作成する
func NewTrackingRepository(db *sql.DB) *TrackingRepository <span class="cov0" title="0">{
        return &amp;TrackingRepository{db: db}
}</span>

// CreateTracking 配送追跡情報を作成する
func (r *TrackingRepository) CreateTracking(ctx context.Context, tracking *models.TrackingInfo) error <span class="cov0" title="0">{
        query := `
                INSERT INTO tracking_info (
                        id, delivery_id, status, current_location,
                        estimated_time, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $6)
                RETURNING created_at, updated_at`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                tracking.ID,
                tracking.DeliveryID,
                tracking.Status,
                tracking.CurrentLocation,
                tracking.EstimatedTime,
                now,
        ).Scan(&amp;tracking.CreatedAt, &amp;tracking.UpdatedAt)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡情報作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTracking 配送追跡情報を取得する
func (r *TrackingRepository) GetTracking(ctx context.Context, trackingID string) (*models.TrackingInfo, error) <span class="cov0" title="0">{
        tracking := &amp;models.TrackingInfo{}
        query := `
                SELECT id, delivery_id, status, current_location,
                        estimated_time, created_at, updated_at
                FROM tracking_info
                WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, trackingID).Scan(
                &amp;tracking.ID,
                &amp;tracking.DeliveryID,
                &amp;tracking.Status,
                &amp;tracking.CurrentLocation,
                &amp;tracking.EstimatedTime,
                &amp;tracking.CreatedAt,
                &amp;tracking.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡情報が見つかりません")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡情報取得エラー: %v", err)
        }</span>

        // イベント履歴の取得
        <span class="cov0" title="0">events, err := r.GetTrackingEvents(ctx, trackingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">tracking.Events = events

        return tracking, nil</span>
}

// UpdateTrackingStatus 配送追跡ステータスを更新する
func (r *TrackingRepository) UpdateTrackingStatus(ctx context.Context, trackingID string, status models.TrackingStatus, location string) error <span class="cov0" title="0">{
        query := `
                UPDATE tracking_info
                SET status = $1, current_location = $2, updated_at = $3
                WHERE id = $4`

        result, err := r.db.ExecContext(ctx, query, status, location, time.Now(), trackingID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡ステータス更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡情報が見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddTrackingEvent 配送追跡イベントを追加する
func (r *TrackingRepository) AddTrackingEvent(ctx context.Context, event *models.TrackingEvent) error <span class="cov0" title="0">{
        query := `
                INSERT INTO tracking_events (
                        tracking_id, status, location, description,
                        latitude, longitude, temperature, humidity,
                        created_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                event.TrackingID,
                event.Status,
                event.Location,
                event.Description,
                event.Latitude,
                event.Longitude,
                event.Temperature,
                event.Humidity,
                now,
        ).Scan(&amp;event.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡イベント追加エラー: %v", err)
        }</span>

        <span class="cov0" title="0">event.CreatedAt = now
        return nil</span>
}

// GetTrackingEvents 配送追跡イベントを取得する
func (r *TrackingRepository) GetTrackingEvents(ctx context.Context, trackingID string) ([]*models.TrackingEvent, error) <span class="cov0" title="0">{
        query := `
                SELECT id, tracking_id, status, location,
                        description, latitude, longitude,
                        temperature, humidity, created_at
                FROM tracking_events
                WHERE tracking_id = $1
                ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query, trackingID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡イベント取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var events []*models.TrackingEvent
        for rows.Next() </span><span class="cov0" title="0">{
                event := &amp;models.TrackingEvent{}
                err := rows.Scan(
                        &amp;event.ID,
                        &amp;event.TrackingID,
                        &amp;event.Status,
                        &amp;event.Location,
                        &amp;event.Description,
                        &amp;event.Latitude,
                        &amp;event.Longitude,
                        &amp;event.Temperature,
                        &amp;event.Humidity,
                        &amp;event.CreatedAt,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配送追跡イベントスキャンエラー: %v", err)
                }</span>
                <span class="cov0" title="0">events = append(events, event)</span>
        }

        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡イベント行処理エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return events, nil</span>
}

// CreateTrackingCondition 追跡条件を作成する
func (r *TrackingRepository) CreateTrackingCondition(ctx context.Context, condition *models.TrackingCondition) error <span class="cov0" title="0">{
        query := `
                INSERT INTO tracking_conditions (
                        tracking_id, min_temperature, max_temperature,
                        min_humidity, max_humidity, check_interval,
                        notify_email, notify_phone, created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $9)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                condition.TrackingID,
                condition.MinTemperature,
                condition.MaxTemperature,
                condition.MinHumidity,
                condition.MaxHumidity,
                condition.CheckInterval,
                condition.NotifyEmail,
                condition.NotifyPhone,
                now,
        ).Scan(&amp;condition.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("追跡条件作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">condition.CreatedAt = now
        condition.UpdatedAt = now
        return nil</span>
}

// GetTrackingCondition 追跡条件を取得する
func (r *TrackingRepository) GetTrackingCondition(ctx context.Context, trackingID string) (*models.TrackingCondition, error) <span class="cov0" title="0">{
        condition := &amp;models.TrackingCondition{}
        query := `
                SELECT id, tracking_id, min_temperature, max_temperature,
                        min_humidity, max_humidity, check_interval,
                        notify_email, notify_phone, created_at, updated_at
                FROM tracking_conditions
                WHERE tracking_id = $1`

        err := r.db.QueryRowContext(ctx, query, trackingID).Scan(
                &amp;condition.ID,
                &amp;condition.TrackingID,
                &amp;condition.MinTemperature,
                &amp;condition.MaxTemperature,
                &amp;condition.MinHumidity,
                &amp;condition.MaxHumidity,
                &amp;condition.CheckInterval,
                &amp;condition.NotifyEmail,
                &amp;condition.NotifyPhone,
                &amp;condition.CreatedAt,
                &amp;condition.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("追跡条件が見つかりません")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("追跡条件取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return condition, nil</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
)

/*
 * ユーザーリポジトリ
 * データベースとのユーザー関連の操作を管理する
 */

// UserRepository ユーザーリポジトリ
type UserRepository struct {
        db *sql.DB
}

// NewUserRepository ユーザーリポジトリを作成する
func NewUserRepository(db *sql.DB) *UserRepository <span class="cov0" title="0">{
        return &amp;UserRepository{db: db}
}</span>

// CreateUser ユーザーを作成する
func (r *UserRepository) CreateUser(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        query := `
                INSERT INTO users (
                        username, email, password_hash, name, role, status,
                        created_at, updated_at
                ) VALUES ($1, $2, $3, $4, $5, $6, $7, $7)
                RETURNING id`

        now := time.Now()
        err := r.db.QueryRowContext(ctx, query,
                user.Username,
                user.Email,
                user.Password,
                user.Name,
                user.Role,
                models.UserStatusActive,
                now,
        ).Scan(&amp;user.ID)

        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ユーザー作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">user.CreatedAt = now
        user.UpdatedAt = now
        return nil</span>
}

// GetUserByEmail メールアドレスでユーザーを取得する
func (r *UserRepository) GetUserByEmail(ctx context.Context, email string) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `
                SELECT id, username, email, password_hash, name, role, status,
                        created_at, updated_at
                FROM users
                WHERE email = $1`

        err := r.db.QueryRowContext(ctx, query, email).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Name,
                &amp;user.Role,
                &amp;user.Status,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ユーザーが見つかりません")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ユーザー取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// GetUserByID IDでユーザーを取得する
func (r *UserRepository) GetUserByID(ctx context.Context, id int64) (*models.User, error) <span class="cov0" title="0">{
        user := &amp;models.User{}
        query := `
                SELECT id, username, email, password_hash, name, role, status,
                        created_at, updated_at
                FROM users
                WHERE id = $1`

        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;user.ID,
                &amp;user.Username,
                &amp;user.Email,
                &amp;user.Password,
                &amp;user.Name,
                &amp;user.Role,
                &amp;user.Status,
                &amp;user.CreatedAt,
                &amp;user.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ユーザーが見つかりません")
        }</span>
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("ユーザー取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// UpdateUser ユーザー情報を更新する
func (r *UserRepository) UpdateUser(ctx context.Context, user *models.User) error <span class="cov0" title="0">{
        query := `
                UPDATE users
                SET name = $1, updated_at = $2
                WHERE id = $3`

        result, err := r.db.ExecContext(ctx, query,
                user.Name,
                time.Now(),
                user.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("ユーザー更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ユーザーが見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdatePassword パスワードを更新する
func (r *UserRepository) UpdatePassword(ctx context.Context, userID int64, hashedPassword string) error <span class="cov0" title="0">{
        query := `
                UPDATE users
                SET password_hash = $1, updated_at = $2
                WHERE id = $3`

        result, err := r.db.ExecContext(ctx, query,
                hashedPassword,
                time.Now(),
                userID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("パスワード更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("結果取得エラー: %v", err)
        }</span>
        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("ユーザーが見つかりません")
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"

        "github.com/gin-gonic/gin"
)

/*
 * 認証ルーティング
 * 認証関連のエンドポイントを定義する
 */

// SetupAuthRoutes 認証ルーティングを設定する
func SetupAuthRoutes(router *gin.Engine, handler *handlers.UserHandler) <span class="cov0" title="0">{
        auth := router.Group("/api/v1/auth")
        </span><span class="cov0" title="0">{
                // 認証不要のエンドポイント
                auth.POST("/login", handler.Login)
                auth.POST("/register", handler.Register)

                // 認証が必要なエンドポイント
                secured := auth.Group("")
                secured.Use(middleware.AuthMiddleware())
                </span><span class="cov0" title="0">{
                        secured.GET("/profile", handler.GetProfile)
                        secured.PUT("/profile", handler.UpdateProfile)
                        secured.PUT("/password", handler.ChangePassword)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file26" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
)

/*
 * 配送ルート
 * 配送関連のエンドポイントを定義する
 */

// SetupDeliveryRoutes 配送ルートを設定する
func SetupDeliveryRoutes(router *gin.Engine, handler *handlers.DeliveryHandler) <span class="cov0" title="0">{
        // 認証が必要なルート
        deliveries := router.Group("/api/deliveries")
        deliveries.Use(middleware.AuthMiddleware())

        // 配送作成 (管理者、マネージャー)
        deliveries.POST("", middleware.RoleAuth(models.RoleAdmin, models.RoleManager), handler.CreateDelivery)

        // 配送一覧取得 (全ロール)
        deliveries.GET("", handler.ListDeliveries)

        // 配送取得 (全ロール)
        deliveries.GET("/:id", handler.GetDelivery)

        // 配送ステータス更新 (管理者、マネージャー、オペレーター)
        deliveries.PUT("/:id/status", middleware.RoleAuth(models.RoleAdmin, models.RoleManager, models.RoleOperator), handler.UpdateDeliveryStatus)

        // 配送完了 (管理者、マネージャー、オペレーター)
        deliveries.POST("/:id/complete", middleware.RoleAuth(models.RoleAdmin, models.RoleManager, models.RoleOperator), handler.CompleteDelivery)

        // 配送追跡作成 (管理者、マネージャー、オペレーター)
        deliveries.POST("/:id/tracking", middleware.RoleAuth(models.RoleAdmin, models.RoleManager, models.RoleOperator), handler.CreateDeliveryTracking)

        // 配送追跡一覧取得 (全ロール)
        deliveries.GET("/:id/tracking", handler.ListDeliveryTrackings)
}</span>
</pre>
		
		<pre class="file" id="file27" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
)

/*
 * 在庫ルーティング
 * 在庫管理関連のエンドポイントを定義する
 */

// SetupInventoryRoutes 在庫ルーティングを設定する
func SetupInventoryRoutes(router *gin.Engine, handler *handlers.InventoryHandler) <span class="cov0" title="0">{
        // 認証が必要なルートグループ
        inventory := router.Group("/api/v1/inventory")
        inventory.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // 在庫情報の取得（閲覧者以上）
                inventory.GET("", middleware.RoleAuth(
                        models.RoleViewer,
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.GetInventory)

                // 在庫の更新（オペレーター以上）
                inventory.PUT("", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.UpdateInventory)

                // 在庫の移動（オペレーター以上）
                inventory.POST("/transfer", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.TransferInventory)

                // 在庫移動の作成（明示API）
                inventory.POST("/movements", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.CreateMovement)

                // 在庫の可用性チェック（閲覧者以上）
                inventory.GET("/check", middleware.RoleAuth(
                        models.RoleViewer,
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.CheckAvailability)
        }</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"

        "github.com/gin-gonic/gin"
)

/*
 * 通知ルーティング
 * 通知関連のエンドポイントを定義する
 */

// SetupNotificationRoutes 通知ルーティングを設定する
func SetupNotificationRoutes(router *gin.Engine, handler *handlers.NotificationHandler) <span class="cov0" title="0">{
        // 認証が必要なルート
        notifications := router.Group("/api/notifications")
        notifications.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                notifications.POST("", handler.CreateNotification)
                notifications.GET("", handler.ListNotifications)
                notifications.GET("/:id", handler.GetNotification)
                notifications.PUT("/:id/read", handler.MarkAsRead)
                notifications.DELETE("/:id", handler.DeleteNotification)
        }</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
)

/*
 * 商品ルーティング
 * 商品関連のエンドポイントを定義する
 */

// SetupProductRoutes 商品ルーティングを設定する
func SetupProductRoutes(router *gin.Engine, handler *handlers.ProductHandler) <span class="cov0" title="0">{
        // 認証が必要なルートグループ
        product := router.Group("/api/v1/products")
        product.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // 商品一覧の取得（閲覧者以上）
                product.GET("", middleware.RoleAuth(
                        models.RoleViewer,
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.ListProducts)

                // 商品詳細の取得（閲覧者以上）
                product.GET("/:id", middleware.RoleAuth(
                        models.RoleViewer,
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.GetProduct)

                // 商品の作成（マネージャー以上）
                product.POST("", middleware.RoleAuth(
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.CreateProduct)

                // 商品の更新（マネージャー以上）
                product.PUT("/:id", middleware.RoleAuth(
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.UpdateProduct)

                // 商品の削除（マネージャー以上）
                product.DELETE("/:id", middleware.RoleAuth(
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.DeleteProduct)
        }</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package routes

import (
        "tea-logistics/pkg/handlers"
        "tea-logistics/pkg/middleware"
        "tea-logistics/pkg/models"

        "github.com/gin-gonic/gin"
)

/*
 * 配送追跡ルーティング
 * 配送追跡関連のエンドポイントを定義する
 */

// SetupTrackingRoutes 配送追跡のルーティングを設定する
func SetupTrackingRoutes(router *gin.Engine, handler *handlers.TrackingHandler) <span class="cov0" title="0">{
        // 認証が必要なルートグループ
        tracking := router.Group("/api/v1/tracking")
        tracking.Use(middleware.AuthMiddleware())
        </span><span class="cov0" title="0">{
                // 配送追跡の初期化（オペレーター以上）
                tracking.POST("/deliveries/:delivery_id/initialize", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.InitializeTracking)

                // 配送追跡ステータスの更新（オペレーター以上）
                tracking.PUT("/:tracking_id/status", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.UpdateTrackingStatus)

                // 配送追跡イベントの追加（オペレーター以上）
                tracking.POST("/:tracking_id/events", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.AddTrackingEvent)

                // 配送追跡情報の取得（閲覧者以上）
                tracking.GET("/:tracking_id", middleware.RoleAuth(
                        models.RoleViewer,
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.GetTrackingInfo)

                // 追跡条件の設定（マネージャー以上）
                tracking.POST("/:tracking_id/conditions", middleware.RoleAuth(
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.SetTrackingCondition)

                // 追跡条件の取得（オペレーター以上）
                tracking.GET("/:tracking_id/conditions", middleware.RoleAuth(
                        models.RoleOperator,
                        models.RoleManager,
                        models.RoleAdmin,
                ), handler.GetTrackingCondition)
        }</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"
)

/*
 * 配送サービス
 * 配送関連のビジネスロジックを実装する
 */

// DeliveryService 配送サービス
type DeliveryService struct {
        repo          repository.DeliveryRepository
        inventoryRepo repository.InventoryRepository
        notifyService NotificationService
}

// NewDeliveryService 配送サービスを作成する
func NewDeliveryService(
        repo repository.DeliveryRepository,
        inventoryRepo repository.InventoryRepository,
        notifyService NotificationService,
) *DeliveryService <span class="cov10" title="4">{
        return &amp;DeliveryService{
                repo:          repo,
                inventoryRepo: inventoryRepo,
                notifyService: notifyService,
        }
}</span>

// CreateDelivery 配送を作成する
func (s *DeliveryService) CreateDelivery(ctx context.Context, req *models.CreateDeliveryRequest) (*models.Delivery, error) <span class="cov1" title="1">{
        // 在庫の確認
        inventory, err := s.inventoryRepo.GetInventory(ctx, req.ProductID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫確認エラー: %v", err)
        }</span>

        <span class="cov1" title="1">if inventory.Quantity &lt; req.Quantity </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫が不足しています")
        }</span>

        // 在庫の更新
        <span class="cov1" title="1">inventory.Quantity -= req.Quantity
        if err := s.inventoryRepo.UpdateInventory(ctx, inventory); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫更新エラー: %v", err)
        }</span>

        // 配送の作成
        <span class="cov1" title="1">delivery := &amp;models.Delivery{
                OrderID:         req.OrderID,
                Status:          "pending",
                FromWarehouseID: req.FromWarehouseID,
                ToAddress:       req.ToAddress,
                EstimatedTime:   req.EstimatedTime,
        }

        if err := s.repo.CreateDelivery(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                // 配送作成に失敗した場合、在庫を戻す
                inventory.Quantity += req.Quantity
                if updateErr := s.inventoryRepo.UpdateInventory(ctx, inventory); updateErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("配送作成エラー: %v, 在庫復元エラー: %v", err, updateErr)
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("配送作成エラー: %v", err)</span>
        }

        // 配送商品の作成
        <span class="cov1" title="1">item := &amp;models.DeliveryItem{
                DeliveryID: delivery.ID,
                ProductID:  req.ProductID,
                Quantity:   req.Quantity,
        }

        if err := s.repo.CreateDeliveryItem(ctx, item); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送商品作成エラー: %v", err)
        }</span>

        // 配送作成の通知
        <span class="cov1" title="1">if s.notifyService != nil </span><span class="cov1" title="1">{
                if err := s.notifyService.NotifyDeliveryStatusChange(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                        // 通知エラーはログに記録するだけで、配送作成自体は成功とする
                        fmt.Printf("通知エラー: %v\n", err)
                }</span>
        }

        <span class="cov1" title="1">return delivery, nil</span>
}

// GetDelivery 配送を取得する
func (s *DeliveryService) GetDelivery(ctx context.Context, id int64) (*models.Delivery, error) <span class="cov1" title="1">{
        delivery, err := s.repo.GetDelivery(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return delivery, nil</span>
}

// ListDeliveries 配送一覧を取得する
func (s *DeliveryService) ListDeliveries(ctx context.Context) ([]*models.Delivery, error) <span class="cov0" title="0">{
        deliveries, err := s.repo.ListDeliveries(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送一覧取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return deliveries, nil</span>
}

// UpdateDeliveryStatus 配送ステータスを更新する
func (s *DeliveryService) UpdateDeliveryStatus(ctx context.Context, id int64, status string) error <span class="cov1" title="1">{
        delivery, err := s.repo.GetDelivery(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">delivery.Status = status
        if status == "delivered" </span><span class="cov0" title="0">{
                delivery.ActualTime = time.Now()
        }</span>

        <span class="cov1" title="1">if err := s.repo.UpdateDelivery(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送更新エラー: %v", err)
        }</span>

        // ステータス更新の通知
        <span class="cov1" title="1">if s.notifyService != nil </span><span class="cov1" title="1">{
                if err := s.notifyService.NotifyDeliveryStatusChange(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                        // 通知エラーはログに記録するだけで、ステータス更新自体は成功とする
                        fmt.Printf("通知エラー: %v\n", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// CreateDeliveryTracking 配送追跡を作成する
func (s *DeliveryService) CreateDeliveryTracking(ctx context.Context, req *models.CreateTrackingRequest) (*models.DeliveryTracking, error) <span class="cov0" title="0">{
        tracking := &amp;models.DeliveryTracking{
                DeliveryID: req.DeliveryID,
                Location:   req.Location,
                Status:     req.Status,
                Notes:      req.Notes,
        }

        if err := s.repo.CreateDeliveryTracking(ctx, tracking); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡作成エラー: %v", err)
        }</span>

        // 配送追跡の通知
        <span class="cov0" title="0">if s.notifyService != nil </span><span class="cov0" title="0">{
                if err := s.notifyService.NotifyDeliveryTracking(ctx, tracking); err != nil </span><span class="cov0" title="0">{
                        // 通知エラーはログに記録するだけで、追跡作成自体は成功とする
                        fmt.Printf("通知エラー: %v\n", err)
                }</span>
        }

        <span class="cov0" title="0">return tracking, nil</span>
}

// ListDeliveryTrackings 配送追跡履歴を取得する
func (s *DeliveryService) ListDeliveryTrackings(ctx context.Context, deliveryID int64) ([]*models.DeliveryTracking, error) <span class="cov0" title="0">{
        trackings, err := s.repo.ListDeliveryTrackings(ctx, deliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("配送追跡履歴取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return trackings, nil</span>
}

// CompleteDelivery 配送を完了する
func (s *DeliveryService) CompleteDelivery(ctx context.Context, id int64) error <span class="cov1" title="1">{
        delivery, err := s.repo.GetDelivery(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">if delivery.Status != "in_transit" </span><span class="cov0" title="0">{
                return fmt.Errorf("配送中の配送のみ完了できます")
        }</span>

        // 在庫の更新
        <span class="cov1" title="1">items, err := s.repo.ListDeliveryItems(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送商品取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">for _, item := range items </span><span class="cov1" title="1">{
                inventory, err := s.inventoryRepo.GetInventory(ctx, item.ProductID)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("在庫取得エラー: %v", err)
                }</span>

                <span class="cov1" title="1">inventory.Quantity -= item.Quantity
                if err := s.inventoryRepo.UpdateInventory(ctx, inventory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("在庫更新エラー: %v", err)
                }</span>
        }

        // 配送ステータスの更新
        <span class="cov1" title="1">delivery.Status = "delivered"
        delivery.ActualTime = time.Now()

        if err := s.repo.UpdateDelivery(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送更新エラー: %v", err)
        }</span>

        // 配送完了の通知
        <span class="cov1" title="1">if s.notifyService != nil </span><span class="cov1" title="1">{
                if err := s.notifyService.NotifyDeliveryComplete(ctx, delivery); err != nil </span><span class="cov0" title="0">{
                        // 通知エラーはログに記録するだけで、配送完了自体は成功とする
                        fmt.Printf("通知エラー: %v\n", err)
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package services

import (
        "context"
        "fmt"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"
)

/*
 * 在庫管理サービス
 * 在庫関連のビジネスロジックを実装する
 */

// InventoryService 在庫管理サービス
type InventoryService struct {
        repo repository.InventoryRepository
}

// NewInventoryService 在庫管理サービスを作成する
func NewInventoryService(repo repository.InventoryRepository) *InventoryService <span class="cov10" title="5">{
        return &amp;InventoryService{repo: repo}
}</span>

// CreateInventory 在庫を作成する
func (s *InventoryService) CreateInventory(ctx context.Context, req *models.CreateInventoryRequest) (*models.Inventory, error) <span class="cov1" title="1">{
        inventory := &amp;models.Inventory{
                ProductID: req.ProductID,
                Quantity:  req.Quantity,
                Location:  req.Location,
                Status:    req.Status,
        }

        if err := s.repo.CreateInventory(ctx, inventory); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫作成エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventory, nil</span>
}

// GetInventory 在庫を取得する
func (s *InventoryService) GetInventory(ctx context.Context, id int64) (*models.Inventory, error) <span class="cov1" title="1">{
        inventory, err := s.repo.GetInventory(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventory, nil</span>
}

// ListInventories 在庫一覧を取得する
func (s *InventoryService) ListInventories(ctx context.Context) ([]*models.Inventory, error) <span class="cov1" title="1">{
        inventories, err := s.repo.ListInventories(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫一覧取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventories, nil</span>
}

// UpdateInventory 在庫を更新する
func (s *InventoryService) UpdateInventory(ctx context.Context, id int64, req *models.UpdateInventoryRequest) (*models.Inventory, error) <span class="cov1" title="1">{
        inventory, err := s.repo.GetInventory(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">inventory.Quantity = req.Quantity
        inventory.Location = req.Location
        inventory.Status = req.Status

        if err := s.repo.UpdateInventory(ctx, inventory); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫更新エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return inventory, nil</span>
}

// DeleteInventory 在庫を削除する
func (s *InventoryService) DeleteInventory(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if err := s.repo.DeleteInventory(ctx, id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫削除エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInventoryByProduct 商品IDから在庫を取得する
func (s *InventoryService) GetInventoryByProduct(ctx context.Context, productID int64) (*models.Inventory, error) <span class="cov0" title="0">{
        inventory, err := s.repo.GetInventoryByProduct(ctx, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return inventory, nil</span>
}

// UpdateQuantity 在庫数を更新する
func (s *InventoryService) UpdateQuantity(ctx context.Context, id int64, quantity int) error <span class="cov0" title="0">{
        if err := s.repo.UpdateQuantity(ctx, id, quantity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫数更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetInventoryByLocation 場所から在庫を取得する
func (s *InventoryService) GetInventoryByLocation(ctx context.Context, location string) ([]*models.Inventory, error) <span class="cov0" title="0">{
        inventories, err := s.repo.GetInventoryByLocation(ctx, location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return inventories, nil</span>
}

// CreateMovement 在庫移動を作成する
func (s *InventoryService) CreateMovement(ctx context.Context, req *models.CreateMovementRequest) (*models.InventoryMovement, error) <span class="cov1" title="1">{
    // 移動元の在庫をロケーション単位で取得
    fromInventory, err := s.GetProductInventory(ctx, req.ProductID, req.FromLocation)
    if err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("移動元在庫取得エラー: %v", err)
    }</span>

    // 在庫数のチェック
    <span class="cov1" title="1">if fromInventory.Quantity &lt; req.Quantity </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("在庫が不足しています")
    }</span>

    // 移動元の在庫を減らす
    <span class="cov1" title="1">if err := s.repo.UpdateQuantity(ctx, fromInventory.ID, fromInventory.Quantity-req.Quantity); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("移動元在庫更新エラー: %v", err)
    }</span>

    // 移動先の在庫をロケーション単位で取得
    <span class="cov1" title="1">toInventory, err := s.GetProductInventory(ctx, req.ProductID, req.ToLocation)
    if err == nil </span><span class="cov0" title="0">{
        // 既存の移動先在庫がある場合は加算
        if err := s.repo.UpdateQuantity(ctx, toInventory.ID, toInventory.Quantity+req.Quantity); err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("移動先在庫更新エラー: %v", err)
        }</span>
    } else<span class="cov1" title="1"> {
        // 移動先に在庫がない場合は新規作成
        newInventory := &amp;models.Inventory{
            ProductID: req.ProductID,
            Quantity:  req.Quantity,
            Location:  req.ToLocation,
            Status:    models.InventoryStatusAvailable,
        }
        if err := s.repo.CreateInventory(ctx, newInventory); err != nil </span><span class="cov0" title="0">{
            return nil, fmt.Errorf("移動先在庫作成エラー: %v", err)
        }</span>
    }

    // 在庫移動を記録
    <span class="cov1" title="1">movement := &amp;models.InventoryMovement{
        ProductID:       req.ProductID,
        FromLocation:    req.FromLocation,
        ToLocation:      req.ToLocation,
        Quantity:        req.Quantity,
        MovementType:    req.MovementType,
        MovementDate:    req.MovementDate,
        ReferenceNumber: req.ReferenceNumber,
    }

    if err := s.repo.CreateMovement(ctx, movement); err != nil </span><span class="cov0" title="0">{
        return nil, fmt.Errorf("在庫移動作成エラー: %v", err)
    }</span>

    <span class="cov1" title="1">return movement, nil</span>
}

// ListMovements 在庫移動履歴を取得する
func (s *InventoryService) ListMovements(ctx context.Context, productID int64) ([]*models.InventoryMovement, error) <span class="cov0" title="0">{
        movements, err := s.repo.ListMovements(ctx, productID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫移動履歴取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return movements, nil</span>
}

// GetProductInventory 商品の在庫を取得する
func (s *InventoryService) GetProductInventory(ctx context.Context, productID int64, location string) (*models.Inventory, error) <span class="cov4" title="2">{
        inventories, err := s.repo.GetInventoryByLocation(ctx, location)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("在庫取得エラー: %v", err)
        }</span>

        <span class="cov4" title="2">for _, inv := range inventories </span><span class="cov1" title="1">{
                if inv.ProductID == productID </span><span class="cov1" title="1">{
                        return inv, nil
                }</span>
        }

        <span class="cov1" title="1">return nil, fmt.Errorf("在庫が見つかりません")</span>
}

// UpdateInventoryQuantity 在庫数を更新する
func (s *InventoryService) UpdateInventoryQuantity(ctx context.Context, productID int64, location string, quantity int) error <span class="cov0" title="0">{
        inventory, err := s.GetProductInventory(ctx, productID, location)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := s.repo.UpdateQuantity(ctx, inventory.ID, quantity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫数更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// TransferInventory 在庫を移動する
func (s *InventoryService) TransferInventory(ctx context.Context, productID int64, fromLocation, toLocation string, quantity int) error <span class="cov0" title="0">{
        // 移動元の在庫を確認
        fromInventory, err := s.GetProductInventory(ctx, productID, fromLocation)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if fromInventory.Quantity &lt; quantity </span><span class="cov0" title="0">{
                return fmt.Errorf("在庫が不足しています")
        }</span>

        // 移動先の在庫を確認
        <span class="cov0" title="0">toInventory, err := s.GetProductInventory(ctx, productID, toLocation)
        if err != nil </span><span class="cov0" title="0">{
                // 移動先に在庫がない場合は新規作成
                toInventory = &amp;models.Inventory{
                        ProductID: productID,
                        Quantity:  0,
                        Location:  toLocation,
                        Status:    models.InventoryStatusAvailable,
                }
                if err := s.repo.CreateInventory(ctx, toInventory); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("移動先在庫作成エラー: %v", err)
                }</span>
        }

        // 移動元の在庫を減らす
        <span class="cov0" title="0">if err := s.repo.UpdateQuantity(ctx, fromInventory.ID, fromInventory.Quantity-quantity); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("移動元在庫更新エラー: %v", err)
        }</span>

        // 移動先の在庫を増やす
        <span class="cov0" title="0">if err := s.repo.UpdateQuantity(ctx, toInventory.ID, toInventory.Quantity+quantity); err != nil </span><span class="cov0" title="0">{
                // 移動先の更新に失敗した場合、移動元を元に戻す
                if restoreErr := s.repo.UpdateQuantity(ctx, fromInventory.ID, fromInventory.Quantity); restoreErr != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("移動先在庫更新エラー: %v, 移動元在庫復元エラー: %v", err, restoreErr)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("移動先在庫更新エラー: %v", err)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// CheckAvailability 在庫の利用可能性をチェックする
func (s *InventoryService) CheckAvailability(ctx context.Context, productID int64, location string, quantity int) (bool, error) <span class="cov0" title="0">{
        inventory, err := s.GetProductInventory(ctx, productID, location)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">return inventory.Quantity &gt;= quantity, nil</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package mocks

import (
        "context"
        "tea-logistics/pkg/models"

        "github.com/stretchr/testify/mock"
)

// MockNotificationService モック通知サービス
type MockNotificationService struct {
        mock.Mock
}

func (m *MockNotificationService) CreateNotification(ctx context.Context, req *models.CreateNotificationRequest) (*models.Notification, error) <span class="cov0" title="0">{
        args := m.Called(ctx, req)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Notification), args.Error(1)</span>
}

func (m *MockNotificationService) GetNotification(ctx context.Context, id int64) (*models.Notification, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Notification), args.Error(1)</span>
}

func (m *MockNotificationService) ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error) <span class="cov0" title="0">{
        args := m.Called(ctx, userID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.Notification), args.Error(1)</span>
}

func (m *MockNotificationService) MarkAsRead(ctx context.Context, id int64) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

func (m *MockNotificationService) DeleteNotification(ctx context.Context, id int64) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

func (m *MockNotificationService) NotifyDeliveryStatusChange(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        args := m.Called(ctx, delivery)
        return args.Error(0)
}</span>

func (m *MockNotificationService) NotifyDeliveryComplete(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        args := m.Called(ctx, delivery)
        return args.Error(0)
}</span>

func (m *MockNotificationService) NotifyDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error <span class="cov0" title="0">{
        args := m.Called(ctx, tracking)
        return args.Error(0)
}</span>
</pre>
		
		<pre class="file" id="file34" style="display: none">package mocks

import (
        "context"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"

        "github.com/stretchr/testify/mock"
)

/*
 * モックリポジトリ
 * テスト用のモックリポジトリを定義する
 */

// MockDeliveryRepository モック配送リポジトリ
type MockDeliveryRepository struct {
        mock.Mock
}

// Ensure MockDeliveryRepository implements DeliveryRepository interface
var _ repository.DeliveryRepository = (*MockDeliveryRepository)(nil)

func (m *MockDeliveryRepository) CreateDelivery(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        args := m.Called(ctx, delivery)
        return args.Error(0)
}</span>

func (m *MockDeliveryRepository) GetDelivery(ctx context.Context, id int64) (*models.Delivery, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Delivery), args.Error(1)</span>
}

func (m *MockDeliveryRepository) ListDeliveries(ctx context.Context) ([]*models.Delivery, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.Delivery), args.Error(1)</span>
}

func (m *MockDeliveryRepository) UpdateDelivery(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        args := m.Called(ctx, delivery)
        return args.Error(0)
}</span>

func (m *MockDeliveryRepository) CreateDeliveryItem(ctx context.Context, item *models.DeliveryItem) error <span class="cov0" title="0">{
        args := m.Called(ctx, item)
        return args.Error(0)
}</span>

func (m *MockDeliveryRepository) ListDeliveryItems(ctx context.Context, deliveryID int64) ([]*models.DeliveryItem, error) <span class="cov0" title="0">{
        args := m.Called(ctx, deliveryID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.DeliveryItem), args.Error(1)</span>
}

func (m *MockDeliveryRepository) CreateDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error <span class="cov0" title="0">{
        args := m.Called(ctx, tracking)
        return args.Error(0)
}</span>

func (m *MockDeliveryRepository) ListDeliveryTrackings(ctx context.Context, deliveryID int64) ([]*models.DeliveryTracking, error) <span class="cov0" title="0">{
        args := m.Called(ctx, deliveryID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.DeliveryTracking), args.Error(1)</span>
}

// MockInventoryRepository モック在庫リポジトリ
type MockInventoryRepository struct {
        mock.Mock
}

// Ensure MockInventoryRepository implements InventoryRepository interface
var _ repository.InventoryRepository = (*MockInventoryRepository)(nil)

func (m *MockInventoryRepository) CreateInventory(ctx context.Context, inventory *models.Inventory) error <span class="cov0" title="0">{
        args := m.Called(ctx, inventory)
        return args.Error(0)
}</span>

func (m *MockInventoryRepository) GetInventory(ctx context.Context, id int64) (*models.Inventory, error) <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Inventory), args.Error(1)</span>
}

func (m *MockInventoryRepository) ListInventories(ctx context.Context) ([]*models.Inventory, error) <span class="cov0" title="0">{
        args := m.Called(ctx)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.Inventory), args.Error(1)</span>
}

func (m *MockInventoryRepository) UpdateInventory(ctx context.Context, inventory *models.Inventory) error <span class="cov0" title="0">{
        args := m.Called(ctx, inventory)
        return args.Error(0)
}</span>

func (m *MockInventoryRepository) DeleteInventory(ctx context.Context, id int64) error <span class="cov0" title="0">{
        args := m.Called(ctx, id)
        return args.Error(0)
}</span>

func (m *MockInventoryRepository) GetInventoryByProduct(ctx context.Context, productID int64) (*models.Inventory, error) <span class="cov0" title="0">{
        args := m.Called(ctx, productID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).(*models.Inventory), args.Error(1)</span>
}

func (m *MockInventoryRepository) UpdateQuantity(ctx context.Context, id int64, quantity int) error <span class="cov0" title="0">{
        args := m.Called(ctx, id, quantity)
        return args.Error(0)
}</span>

func (m *MockInventoryRepository) GetInventoryByLocation(ctx context.Context, location string) ([]*models.Inventory, error) <span class="cov0" title="0">{
        args := m.Called(ctx, location)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.Inventory), args.Error(1)</span>
}

func (m *MockInventoryRepository) CreateMovement(ctx context.Context, movement *models.InventoryMovement) error <span class="cov0" title="0">{
        args := m.Called(ctx, movement)
        return args.Error(0)
}</span>

func (m *MockInventoryRepository) ListMovements(ctx context.Context, productID int64) ([]*models.InventoryMovement, error) <span class="cov0" title="0">{
        args := m.Called(ctx, productID)
        if args.Get(0) == nil </span><span class="cov0" title="0">{
                return nil, args.Error(1)
        }</span>
        <span class="cov0" title="0">return args.Get(0).([]*models.InventoryMovement), args.Error(1)</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"
)

/*
 * 通知サービス
 * 通知関連のビジネスロジックを実装する
 */

// NotificationService 通知サービスインターフェース
type NotificationService interface {
        CreateNotification(ctx context.Context, req *models.CreateNotificationRequest) (*models.Notification, error)
        GetNotification(ctx context.Context, id int64) (*models.Notification, error)
        ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error)
        MarkAsRead(ctx context.Context, id int64) error
        DeleteNotification(ctx context.Context, id int64) error
        NotifyDeliveryStatusChange(ctx context.Context, delivery *models.Delivery) error
        NotifyDeliveryComplete(ctx context.Context, delivery *models.Delivery) error
        NotifyDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error
}

// NotificationServiceImpl 通知サービス実装
type NotificationServiceImpl struct {
        repo         repository.NotificationRepository
        deliveryRepo repository.DeliveryRepository
}

// NewNotificationService 通知サービスを作成する
func NewNotificationService(repo repository.NotificationRepository, deliveryRepo repository.DeliveryRepository) NotificationService <span class="cov0" title="0">{
        return &amp;NotificationServiceImpl{
                repo:         repo,
                deliveryRepo: deliveryRepo,
        }
}</span>

// CreateNotification 通知を作成する
func (s *NotificationServiceImpl) CreateNotification(ctx context.Context, req *models.CreateNotificationRequest) (*models.Notification, error) <span class="cov0" title="0">{
        notification := &amp;models.Notification{
                Type:      req.Type,
                Status:    models.NotificationStatusUnread,
                Title:     req.Title,
                Message:   req.Message,
                Data:      req.Data,
                UserID:    req.UserID,
                CreatedAt: time.Now(),
                UpdatedAt: time.Now(),
        }

        if err := s.repo.CreateNotification(ctx, notification); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知作成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return notification, nil</span>
}

// GetNotification 通知を取得する
func (s *NotificationServiceImpl) GetNotification(ctx context.Context, id int64) (*models.Notification, error) <span class="cov0" title="0">{
        notification, err := s.repo.GetNotification(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return notification, nil</span>
}

// ListNotifications ユーザーの通知一覧を取得する
func (s *NotificationServiceImpl) ListNotifications(ctx context.Context, userID int64) ([]*models.Notification, error) <span class="cov0" title="0">{
        notifications, err := s.repo.ListNotifications(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("通知一覧取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return notifications, nil</span>
}

// MarkAsRead 通知を既読にする
func (s *NotificationServiceImpl) MarkAsRead(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if err := s.repo.UpdateNotificationStatus(ctx, id, models.NotificationStatusRead); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("通知ステータス更新エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// DeleteNotification 通知を削除する
func (s *NotificationServiceImpl) DeleteNotification(ctx context.Context, id int64) error <span class="cov0" title="0">{
        if err := s.repo.DeleteNotification(ctx, id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("通知削除エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NotifyDeliveryStatusChange 配送ステータス変更を通知する
func (s *NotificationServiceImpl) NotifyDeliveryStatusChange(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        req := &amp;models.CreateNotificationRequest{
                Type:    models.NotificationTypeDeliveryStatus,
                Title:   "配送ステータスが更新されました",
                Message: fmt.Sprintf("配送ID: %d のステータスが「%s」に更新されました", delivery.ID, delivery.Status),
                Data: map[string]interface{}{
                        "delivery_id": delivery.ID,
                        "status":      delivery.Status,
                },
                UserID: delivery.OrderID, // 注文IDをユーザーIDとして使用
        }

        _, err := s.CreateNotification(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送ステータス変更通知エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NotifyDeliveryComplete 配送完了を通知する
func (s *NotificationServiceImpl) NotifyDeliveryComplete(ctx context.Context, delivery *models.Delivery) error <span class="cov0" title="0">{
        req := &amp;models.CreateNotificationRequest{
                Type:    models.NotificationTypeDeliveryComplete,
                Title:   "配送が完了しました",
                Message: fmt.Sprintf("配送ID: %d の配送が完了しました", delivery.ID),
                Data: map[string]interface{}{
                        "delivery_id":  delivery.ID,
                        "completed_at": delivery.ActualTime,
                },
                UserID: delivery.OrderID, // 注文IDをユーザーIDとして使用
        }

        _, err := s.CreateNotification(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送完了通知エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// NotifyDeliveryTracking 配送追跡を通知する
func (s *NotificationServiceImpl) NotifyDeliveryTracking(ctx context.Context, tracking *models.DeliveryTracking) error <span class="cov0" title="0">{
        // 配送情報を取得
        delivery, err := s.deliveryRepo.GetDelivery(ctx, tracking.DeliveryID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送情報取得エラー: %v", err)
        }</span>

        <span class="cov0" title="0">req := &amp;models.CreateNotificationRequest{
                Type:    models.NotificationTypeDeliveryTracking,
                Title:   "配送状況が更新されました",
                Message: fmt.Sprintf("配送ID: %d の現在位置: %s", tracking.DeliveryID, tracking.Location),
                Data: map[string]interface{}{
                        "delivery_id": tracking.DeliveryID,
                        "location":    tracking.Location,
                        "status":      tracking.Status,
                },
                UserID: delivery.OrderID, // 配送のOrderIDを使用
        }

        _, err = s.CreateNotification(ctx, req)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("配送追跡通知エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file36" style="display: none">package services

import (
        "context"
        "fmt"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"
)

/*
 * 商品サービス
 * 商品関連のビジネスロジックを実装する
 */

// ProductService 商品サービス
type ProductService struct {
        repo repository.ProductRepository
}

// NewProductService 商品サービスを作成する
func NewProductService(repo repository.ProductRepository) *ProductService <span class="cov10" title="5">{
        return &amp;ProductService{repo: repo}
}</span>

// CreateProduct 商品を作成する
func (s *ProductService) CreateProduct(ctx context.Context, req *models.CreateProductRequest) (*models.Product, error) <span class="cov1" title="1">{
        product := &amp;models.Product{
                Name:        req.Name,
                Description: req.Description,
                SKU:         req.SKU,
                Category:    req.Category,
                Price:       req.Price,
                Status:      req.Status,
        }

        if err := s.repo.CreateProduct(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品作成エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return product, nil</span>
}

// GetProduct 商品を取得する
func (s *ProductService) GetProduct(ctx context.Context, id int64) (*models.Product, error) <span class="cov1" title="1">{
        product, err := s.repo.GetProduct(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return product, nil</span>
}

// ListProducts 商品一覧を取得する
func (s *ProductService) ListProducts(ctx context.Context) ([]*models.Product, error) <span class="cov1" title="1">{
        products, err := s.repo.ListProducts(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品一覧取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return products, nil</span>
}

// UpdateProduct 商品を更新する
func (s *ProductService) UpdateProduct(ctx context.Context, id int64, req *models.UpdateProductRequest) (*models.Product, error) <span class="cov1" title="1">{
        product, err := s.repo.GetProduct(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品取得エラー: %v", err)
        }</span>

        <span class="cov1" title="1">product.Name = req.Name
        product.Description = req.Description
        product.SKU = req.SKU
        product.Category = req.Category
        product.Price = req.Price
        product.Status = req.Status

        if err := s.repo.UpdateProduct(ctx, product); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("商品更新エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return product, nil</span>
}

// DeleteProduct 商品を削除する
func (s *ProductService) DeleteProduct(ctx context.Context, id int64) error <span class="cov1" title="1">{
        if err := s.repo.DeleteProduct(ctx, id); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("商品削除エラー: %v", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file37" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"
)

/*
 * 配送追跡サービス
 * 配送追跡関連のビジネスロジックを実装する
 */

// TrackingService 配送追跡サービス
type TrackingService struct {
        trackingRepo *repository.TrackingRepository
}

// NewTrackingService 配送追跡サービスを作成する
func NewTrackingService(trackingRepo *repository.TrackingRepository) *TrackingService <span class="cov0" title="0">{
        return &amp;TrackingService{trackingRepo: trackingRepo}
}</span>

// InitializeTracking 配送追跡を初期化する
func (s *TrackingService) InitializeTracking(ctx context.Context, deliveryID int64, fromLocation string) (*models.TrackingInfo, error) <span class="cov0" title="0">{
        tracking := &amp;models.TrackingInfo{
                ID:              fmt.Sprintf("TRK-%d", time.Now().Unix()),
                DeliveryID:      deliveryID,
                Status:          models.TrackingStatusRegistered,
                CurrentLocation: fromLocation,
                Events:          make([]*models.TrackingEvent, 0),
        }

        if err := s.trackingRepo.CreateTracking(ctx, tracking); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 初期イベントの追加
        <span class="cov0" title="0">event := &amp;models.TrackingEvent{
                TrackingID:  tracking.ID,
                Status:      models.TrackingStatusRegistered,
                Location:    fromLocation,
                Description: "配送追跡が開始されました",
        }
        if err := s.trackingRepo.AddTrackingEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tracking, nil</span>
}

// UpdateTrackingStatus 配送追跡ステータスを更新する
func (s *TrackingService) UpdateTrackingStatus(ctx context.Context, trackingID string, status models.TrackingStatus, location string, description string) error <span class="cov0" title="0">{
        // ステータスの更新
        if err := s.trackingRepo.UpdateTrackingStatus(ctx, trackingID, status, location); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // イベントの追加
        <span class="cov0" title="0">event := &amp;models.TrackingEvent{
                TrackingID:  trackingID,
                Status:      status,
                Location:    location,
                Description: description,
        }
        if err := s.trackingRepo.AddTrackingEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// AddTrackingEvent 配送追跡イベントを追加する
func (s *TrackingService) AddTrackingEvent(ctx context.Context, event *models.TrackingEvent) error <span class="cov0" title="0">{
        // 追跡情報の存在確認
        tracking, err := s.trackingRepo.GetTracking(ctx, event.TrackingID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // イベントの追加
        <span class="cov0" title="0">if err := s.trackingRepo.AddTrackingEvent(ctx, event); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 条件チェック
        <span class="cov0" title="0">condition, err := s.trackingRepo.GetTrackingCondition(ctx, tracking.ID)
        if err == nil </span><span class="cov0" title="0">{
                // 温度チェック
                if event.Temperature &lt; condition.MinTemperature || event.Temperature &gt; condition.MaxTemperature </span><span class="cov0" title="0">{
                        // TODO: 通知を送信する
                        return fmt.Errorf("温度が範囲外です: %.2f°C", event.Temperature)
                }</span>

                // 湿度チェック
                <span class="cov0" title="0">if event.Humidity &lt; condition.MinHumidity || event.Humidity &gt; condition.MaxHumidity </span><span class="cov0" title="0">{
                        // TODO: 通知を送信する
                        return fmt.Errorf("湿度が範囲外です: %.2f%%", event.Humidity)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// GetTrackingInfo 配送追跡情報を取得する
func (s *TrackingService) GetTrackingInfo(ctx context.Context, trackingID string) (*models.TrackingInfo, error) <span class="cov0" title="0">{
        return s.trackingRepo.GetTracking(ctx, trackingID)
}</span>

// SetTrackingCondition 追跡条件を設定する
func (s *TrackingService) SetTrackingCondition(ctx context.Context, condition *models.TrackingCondition) error <span class="cov0" title="0">{
        // 追跡情報の存在確認
        if _, err := s.trackingRepo.GetTracking(ctx, condition.TrackingID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 条件の作成
        <span class="cov0" title="0">if err := s.trackingRepo.CreateTrackingCondition(ctx, condition); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetTrackingCondition 追跡条件を取得する
func (s *TrackingService) GetTrackingCondition(ctx context.Context, trackingID string) (*models.TrackingCondition, error) <span class="cov0" title="0">{
        return s.trackingRepo.GetTrackingCondition(ctx, trackingID)
}</span>
</pre>
		
		<pre class="file" id="file38" style="display: none">package services

import (
        "context"
        "fmt"
        "time"

        "tea-logistics/pkg/config"
        "tea-logistics/pkg/models"
        "tea-logistics/pkg/repository"

        "github.com/golang-jwt/jwt"
)

/*
 * ユーザーサービス
 * ユーザー関連のビジネスロジックを実装する
 */

// UserService ユーザーサービス
type UserService struct {
        repo *repository.UserRepository
}

// NewUserService ユーザーサービスを作成する
func NewUserService(repo *repository.UserRepository) *UserService <span class="cov0" title="0">{
        return &amp;UserService{repo: repo}
}</span>

// Login ユーザーログイン
func (s *UserService) Login(ctx context.Context, req *models.LoginRequest) (string, error) <span class="cov0" title="0">{
        user, err := s.repo.GetUserByEmail(ctx, req.Email)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">if !user.CheckPassword(req.Password) </span><span class="cov0" title="0">{
                return "", fmt.Errorf("パスワードが正しくありません")
        }</span>

        // JWTトークンの生成
        <span class="cov0" title="0">cfg, err := config.LoadConfig()
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
                "user_id": user.ID,
                "role":    user.Role,
                "exp":     time.Now().Add(24 * time.Hour).Unix(),
        })

        tokenString, err := token.SignedString([]byte(cfg.JWTSecret))
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("トークン生成エラー: %v", err)
        }</span>

        <span class="cov0" title="0">return tokenString, nil</span>
}

// Register ユーザー登録
func (s *UserService) Register(ctx context.Context, req *models.RegisterRequest) error <span class="cov0" title="0">{
        // メールアドレスの重複チェック
        _, err := s.repo.GetUserByEmail(ctx, req.Email)
        if err == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("このメールアドレスは既に登録されています")
        }</span>

        <span class="cov0" title="0">user := &amp;models.User{
                Username: req.Username,
                Email:    req.Email,
                Password: req.Password,
                Name:     req.Name,
                Role:     req.Role,
                Status:   models.UserStatusActive,
        }

        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("パスワードのハッシュ化に失敗しました: %v", err)
        }</span>

        <span class="cov0" title="0">if err := s.repo.CreateUser(ctx, user); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetProfile プロフィール取得
func (s *UserService) GetProfile(ctx context.Context, userID int64) (*models.User, error) <span class="cov0" title="0">{
        return s.repo.GetUserByID(ctx, userID)
}</span>

// UpdateProfile プロフィール更新
func (s *UserService) UpdateProfile(ctx context.Context, userID int64, req *models.UpdateProfileRequest) error <span class="cov0" title="0">{
        user, err := s.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">user.Name = req.Name
        return s.repo.UpdateUser(ctx, user)</span>
}

// ChangePassword パスワード変更
func (s *UserService) ChangePassword(ctx context.Context, userID int64, req *models.ChangePasswordRequest) error <span class="cov0" title="0">{
        user, err := s.repo.GetUserByID(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !user.CheckPassword(req.OldPassword) </span><span class="cov0" title="0">{
                return fmt.Errorf("現在のパスワードが正しくありません")
        }</span>

        <span class="cov0" title="0">user.Password = req.NewPassword
        if err := user.HashPassword(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("パスワードのハッシュ化に失敗しました: %v", err)
        }</span>

        <span class="cov0" title="0">return s.repo.UpdatePassword(ctx, userID, user.Password)</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">package tests

import (
        "database/sql"
        "fmt"
        "log"
        "os"
        "tea-logistics/pkg/repository"

        _ "github.com/lib/pq"
)

/*
 * テストヘルパー関数
 * テスト用のDBセットアップと後片付けを行う
 */

var testDB *sql.DB

// setupTestDB テスト用のDBをセットアップする
func setupTestDB() repository.DB <span class="cov1" title="1">{
        if testDB != nil </span><span class="cov0" title="0">{
                return repository.NewSQLDatabase(testDB)
        }</span>

        // テスト用のDB接続情報
        <span class="cov1" title="1">dbHost := os.Getenv("TEST_DB_HOST")
        if dbHost == "" </span><span class="cov1" title="1">{
                dbHost = "localhost"
        }</span>
        <span class="cov1" title="1">dbPort := os.Getenv("TEST_DB_PORT")
        if dbPort == "" </span><span class="cov1" title="1">{
                dbPort = "5432"
        }</span>
        <span class="cov1" title="1">dbName := os.Getenv("TEST_DB_NAME")
        if dbName == "" </span><span class="cov1" title="1">{
                dbName = "tea_logistics_test"
        }</span>
        <span class="cov1" title="1">dbUser := os.Getenv("TEST_DB_USER")
        if dbUser == "" </span><span class="cov1" title="1">{
                dbUser = "postgres"
        }</span>
        <span class="cov1" title="1">dbPassword := os.Getenv("TEST_DB_PASSWORD")
        if dbPassword == "" </span><span class="cov1" title="1">{
                dbPassword = "postgres"
        }</span>

        // DB接続
        <span class="cov1" title="1">connStr := fmt.Sprintf(
                "host=%s port=%s dbname=%s user=%s password=%s sslmode=disable",
                dbHost, dbPort, dbName, dbUser, dbPassword,
        )
        db, err := sql.Open("postgres", connStr)
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("テストDB接続エラー: %v", err)
        }</span>

        // テーブルの作成
        <span class="cov1" title="1">if err := createTestTables(db); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("テストテーブル作成エラー: %v", err)
        }</span>

        <span class="cov1" title="1">testDB = db
        return repository.NewSQLDatabase(db)</span>
}

// cleanupTestDB テスト用のDBをクリーンアップする
func cleanupTestDB() <span class="cov1" title="1">{
        if testDB == nil </span><span class="cov0" title="0">{
                return
        }</span>

        // テーブルのクリーンアップ
        <span class="cov1" title="1">if err := cleanupTestTables(testDB); err != nil </span><span class="cov0" title="0">{
                log.Printf("テストテーブルクリーンアップエラー: %v", err)
        }</span>

        <span class="cov1" title="1">if err := testDB.Close(); err != nil </span><span class="cov0" title="0">{
                log.Printf("テストDB切断エラー: %v", err)
        }</span>
        <span class="cov1" title="1">testDB = nil</span>
}

// createTestTables テストテーブルを作成する
func createTestTables(db *sql.DB) error <span class="cov1" title="1">{
        queries := []string{
                `CREATE TABLE IF NOT EXISTS notifications (
                        id SERIAL PRIMARY KEY,
                        type VARCHAR(50) NOT NULL,
                        status VARCHAR(20) NOT NULL,
                        title VARCHAR(200) NOT NULL,
                        message TEXT NOT NULL,
                        data JSONB,
                        user_id INTEGER NOT NULL,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE TABLE IF NOT EXISTS deliveries (
                        id SERIAL PRIMARY KEY,
                        order_id INTEGER NOT NULL,
                        status VARCHAR(50) NOT NULL,
                        from_warehouse_id INTEGER NOT NULL,
                        to_address TEXT NOT NULL,
                        estimated_time TIMESTAMP NOT NULL,
                        actual_time TIMESTAMP,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
                )`,
                `CREATE TABLE IF NOT EXISTS delivery_trackings (
                        id SERIAL PRIMARY KEY,
                        delivery_id INTEGER NOT NULL,
                        location TEXT NOT NULL,
                        status VARCHAR(50) NOT NULL,
                        notes TEXT,
                        created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (delivery_id) REFERENCES deliveries(id)
                )`,
        }

        for _, query := range queries </span><span class="cov10" title="3">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}

// cleanupTestTables テストテーブルをクリーンアップする
func cleanupTestTables(db *sql.DB) error <span class="cov1" title="1">{
        queries := []string{
                "DELETE FROM delivery_trackings",
                "DELETE FROM deliveries",
                "DELETE FROM notifications",
        }

        for _, query := range queries </span><span class="cov10" title="3">{
                if _, err := db.Exec(query); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov1" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
